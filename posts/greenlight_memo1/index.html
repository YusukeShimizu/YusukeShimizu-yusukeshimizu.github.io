<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Greenlight SchedulerとSignerの関係性 | blog</title>
<meta name=keywords content><meta name=description content="greenlight proto をベースにした解説。
目的と結論
Greenlight では、Scheduler (Closed Source) が Node 管理の中心にあり、UserClient (with integrated Signer/HSM) が Self-Hosted 環境で秘密鍵を保持する構造をとる。結論として、UserClient 側が鍵操作を制御しつつ、Greenlight 側の Scheduler が Node (CLN) を起動・管理する。これにより、秘密鍵をローカルで保持したまま Node をリモートで稼働させる運用が可能となる。

全体構造
以下の図に示すように、UserClient (with integrated Signer/HSM) は自前の環境 (Self-Hosted) で動作する。一方、Scheduler は Greenlight が管理し、CLN (c-lightning+plugin) も Greenlight Hosted 環境で稼働する。UserClient は Scheduler に対して Manage API call を行い、Node に対する操作は Scheduler が CLN を経由して実行する。Signer/HSM は秘密鍵をローカルで保持し、署名要求のみを受け付ける。
(Self-Hosted)                                                    (Greenlight Hosted)
  +-----------------------------------+   (Manage API call)   +----------------------------+
  | UserClient (with integrated       | --------------------> | Scheduler (Closed Source)  |
  | Signer / HSM)                     |                       +-------------+--------------+
  +-----------------------------------+                                     |
                                     |                              (Node management)
                                     |                                      v
                                     |                           +------------------------+
                                     |----------------------->   |CLN (c-lightning+plugin)|
                                                                 +-----------+------------+

ノード登録とスケジューリングフロー
チャレンジ発行 (GetChallenge)

スコープ (REGISTER や RECOVER) と node_id を指定し、Scheduler に GetChallenge をコールする。
Scheduler は一度きり有効な challenge を生成し、ChallengeResponse に含めて返す。

Register / Recover

クライアントは challenge を秘密鍵で署名し、node_id、network、CSR などと共に送信する。
Scheduler は署名検証後にノード所有権を確認し、mTLS のための device_cert と device_key を発行する。
Register は新規発行、Recover は既存ノードの証明書再発行となる。

Schedule / GetNodeInfo

クライアントは Schedule を呼び出し、ノード起動をリクエストする。
Scheduler は CLN を割り当て、grpc_uri など接続情報を返す。
すでに起動済みの場合、GetNodeInfo で接続情報を取得可能である。

接続・操作

クライアントは取得した device_cert と device_key を用い、mTLS で CLN (node) に接続する。
支払いやチャネル操作などの RPC 呼び出しを行う。
署名が必要な場合、CLN は Signer (HSM) へ HsmRequest を送信し、秘密鍵を外部に渡さずに署名のみを実行する。


Signer フロー (HSMRequest / HsmService)
CLN は秘密鍵が必要なとき、Node Service の StreamHsmRequests を用いて外部サイナー (Signer/HSM) へ HsmRequest を通知する。Signer はローカルで署名を実施し、HsmResponse で返す。具体的な流れは以下の通りである。"><meta name=author content><link rel=canonical href=https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://yusukeshimizu.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yusukeshimizu.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yusukeshimizu.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://yusukeshimizu.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://yusukeshimizu.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const elementCode=".mermaid",loadMermaid=function(e){mermaid.initialize({theme:e}),mermaid.init({theme:e},document.querySelectorAll(elementCode))},saveOriginalData=function(){return new Promise((e,t)=>{try{var n=document.querySelectorAll(elementCode),s=n.length;n.forEach(t=>{t.setAttribute("data-original-code",t.innerHTML),s--,s==0&&e()})}catch(e){t(e)}})},resetProcessed=function(){return new Promise((e,t)=>{try{var n=document.querySelectorAll(elementCode),s=n.length;n.forEach(t=>{t.getAttribute("data-original-code")!=null&&(t.removeAttribute("data-processed"),t.innerHTML=t.getAttribute("data-original-code")),s--,s==0&&e()})}catch(e){t(e)}})};saveOriginalData().catch(console.error);let statusTheme=localStorage.getItem("pref-theme");statusTheme=="dark"&&resetProcessed().then(loadMermaid("dark")).catch(console.error),statusTheme=="light"&&resetProcessed().then(loadMermaid("neutral")).catch(console.error),document.getElementById("theme-toggle").addEventListener("click",()=>{resetProcessed().then(loadMermaid(mermaid.mermaidAPI.getConfig().theme=="neutral"?"dark":"neutral")).catch(console.error)})</script><meta property="og:url" content="https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/"><meta property="og:site_name" content="blog"><meta property="og:title" content="Greenlight SchedulerとSignerの関係性"><meta property="og:description" content="greenlight proto をベースにした解説。
目的と結論
Greenlight では、Scheduler (Closed Source) が Node 管理の中心にあり、UserClient (with integrated Signer/HSM) が Self-Hosted 環境で秘密鍵を保持する構造をとる。結論として、UserClient 側が鍵操作を制御しつつ、Greenlight 側の Scheduler が Node (CLN) を起動・管理する。これにより、秘密鍵をローカルで保持したまま Node をリモートで稼働させる運用が可能となる。
全体構造 以下の図に示すように、UserClient (with integrated Signer/HSM) は自前の環境 (Self-Hosted) で動作する。一方、Scheduler は Greenlight が管理し、CLN (c-lightning+plugin) も Greenlight Hosted 環境で稼働する。UserClient は Scheduler に対して Manage API call を行い、Node に対する操作は Scheduler が CLN を経由して実行する。Signer/HSM は秘密鍵をローカルで保持し、署名要求のみを受け付ける。
(Self-Hosted) (Greenlight Hosted) +-----------------------------------+ (Manage API call) +----------------------------+ | UserClient (with integrated | --------------------> | Scheduler (Closed Source) | | Signer / HSM) | +-------------+--------------+ +-----------------------------------+ | | (Node management) | v | +------------------------+ |-----------------------> |CLN (c-lightning+plugin)| +-----------+------------+ ノード登録とスケジューリングフロー チャレンジ発行 (GetChallenge) スコープ (REGISTER や RECOVER) と node_id を指定し、Scheduler に GetChallenge をコールする。 Scheduler は一度きり有効な challenge を生成し、ChallengeResponse に含めて返す。 Register / Recover クライアントは challenge を秘密鍵で署名し、node_id、network、CSR などと共に送信する。 Scheduler は署名検証後にノード所有権を確認し、mTLS のための device_cert と device_key を発行する。 Register は新規発行、Recover は既存ノードの証明書再発行となる。 Schedule / GetNodeInfo クライアントは Schedule を呼び出し、ノード起動をリクエストする。 Scheduler は CLN を割り当て、grpc_uri など接続情報を返す。 すでに起動済みの場合、GetNodeInfo で接続情報を取得可能である。 接続・操作 クライアントは取得した device_cert と device_key を用い、mTLS で CLN (node) に接続する。 支払いやチャネル操作などの RPC 呼び出しを行う。 署名が必要な場合、CLN は Signer (HSM) へ HsmRequest を送信し、秘密鍵を外部に渡さずに署名のみを実行する。 Signer フロー (HSMRequest / HsmService) CLN は秘密鍵が必要なとき、Node Service の StreamHsmRequests を用いて外部サイナー (Signer/HSM) へ HsmRequest を通知する。Signer はローカルで署名を実施し、HsmResponse で返す。具体的な流れは以下の通りである。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-19T11:07:52+09:00"><meta property="article:modified_time" content="2025-03-19T11:07:52+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Greenlight SchedulerとSignerの関係性"><meta name=twitter:description content="greenlight proto をベースにした解説。
目的と結論
Greenlight では、Scheduler (Closed Source) が Node 管理の中心にあり、UserClient (with integrated Signer/HSM) が Self-Hosted 環境で秘密鍵を保持する構造をとる。結論として、UserClient 側が鍵操作を制御しつつ、Greenlight 側の Scheduler が Node (CLN) を起動・管理する。これにより、秘密鍵をローカルで保持したまま Node をリモートで稼働させる運用が可能となる。

全体構造
以下の図に示すように、UserClient (with integrated Signer/HSM) は自前の環境 (Self-Hosted) で動作する。一方、Scheduler は Greenlight が管理し、CLN (c-lightning+plugin) も Greenlight Hosted 環境で稼働する。UserClient は Scheduler に対して Manage API call を行い、Node に対する操作は Scheduler が CLN を経由して実行する。Signer/HSM は秘密鍵をローカルで保持し、署名要求のみを受け付ける。
(Self-Hosted)                                                    (Greenlight Hosted)
  +-----------------------------------+   (Manage API call)   +----------------------------+
  | UserClient (with integrated       | --------------------> | Scheduler (Closed Source)  |
  | Signer / HSM)                     |                       +-------------+--------------+
  +-----------------------------------+                                     |
                                     |                              (Node management)
                                     |                                      v
                                     |                           +------------------------+
                                     |----------------------->   |CLN (c-lightning+plugin)|
                                                                 +-----------+------------+

ノード登録とスケジューリングフロー
チャレンジ発行 (GetChallenge)

スコープ (REGISTER や RECOVER) と node_id を指定し、Scheduler に GetChallenge をコールする。
Scheduler は一度きり有効な challenge を生成し、ChallengeResponse に含めて返す。

Register / Recover

クライアントは challenge を秘密鍵で署名し、node_id、network、CSR などと共に送信する。
Scheduler は署名検証後にノード所有権を確認し、mTLS のための device_cert と device_key を発行する。
Register は新規発行、Recover は既存ノードの証明書再発行となる。

Schedule / GetNodeInfo

クライアントは Schedule を呼び出し、ノード起動をリクエストする。
Scheduler は CLN を割り当て、grpc_uri など接続情報を返す。
すでに起動済みの場合、GetNodeInfo で接続情報を取得可能である。

接続・操作

クライアントは取得した device_cert と device_key を用い、mTLS で CLN (node) に接続する。
支払いやチャネル操作などの RPC 呼び出しを行う。
署名が必要な場合、CLN は Signer (HSM) へ HsmRequest を送信し、秘密鍵を外部に渡さずに署名のみを実行する。


Signer フロー (HSMRequest / HsmService)
CLN は秘密鍵が必要なとき、Node Service の StreamHsmRequests を用いて外部サイナー (Signer/HSM) へ HsmRequest を通知する。Signer はローカルで署名を実施し、HsmResponse で返す。具体的な流れは以下の通りである。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yusukeshimizu.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Greenlight SchedulerとSignerの関係性","item":"https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Greenlight SchedulerとSignerの関係性","name":"Greenlight SchedulerとSignerの関係性","description":"greenlight proto をベースにした解説。\n目的と結論\nGreenlight では、Scheduler (Closed Source) が Node 管理の中心にあり、UserClient (with integrated Signer/HSM) が Self-Hosted 環境で秘密鍵を保持する構造をとる。結論として、UserClient 側が鍵操作を制御しつつ、Greenlight 側の Scheduler が Node (CLN) を起動・管理する。これにより、秘密鍵をローカルで保持したまま Node をリモートで稼働させる運用が可能となる。\n全体構造 以下の図に示すように、UserClient (with integrated Signer/HSM) は自前の環境 (Self-Hosted) で動作する。一方、Scheduler は Greenlight が管理し、CLN (c-lightning+plugin) も Greenlight Hosted 環境で稼働する。UserClient は Scheduler に対して Manage API call を行い、Node に対する操作は Scheduler が CLN を経由して実行する。Signer/HSM は秘密鍵をローカルで保持し、署名要求のみを受け付ける。\n(Self-Hosted) (Greenlight Hosted) +-----------------------------------+ (Manage API call) +----------------------------+ | UserClient (with integrated | --------------------\u0026gt; | Scheduler (Closed Source) | | Signer / HSM) | +-------------+--------------+ +-----------------------------------+ | | (Node management) | v | +------------------------+ |-----------------------\u0026gt; |CLN (c-lightning+plugin)| +-----------+------------+ ノード登録とスケジューリングフロー チャレンジ発行 (GetChallenge) スコープ (REGISTER や RECOVER) と node_id を指定し、Scheduler に GetChallenge をコールする。 Scheduler は一度きり有効な challenge を生成し、ChallengeResponse に含めて返す。 Register / Recover クライアントは challenge を秘密鍵で署名し、node_id、network、CSR などと共に送信する。 Scheduler は署名検証後にノード所有権を確認し、mTLS のための device_cert と device_key を発行する。 Register は新規発行、Recover は既存ノードの証明書再発行となる。 Schedule / GetNodeInfo クライアントは Schedule を呼び出し、ノード起動をリクエストする。 Scheduler は CLN を割り当て、grpc_uri など接続情報を返す。 すでに起動済みの場合、GetNodeInfo で接続情報を取得可能である。 接続・操作 クライアントは取得した device_cert と device_key を用い、mTLS で CLN (node) に接続する。 支払いやチャネル操作などの RPC 呼び出しを行う。 署名が必要な場合、CLN は Signer (HSM) へ HsmRequest を送信し、秘密鍵を外部に渡さずに署名のみを実行する。 Signer フロー (HSMRequest / HsmService) CLN は秘密鍵が必要なとき、Node Service の StreamHsmRequests を用いて外部サイナー (Signer/HSM) へ HsmRequest を通知する。Signer はローカルで署名を実施し、HsmResponse で返す。具体的な流れは以下の通りである。\n","keywords":[],"articleBody":"greenlight proto をベースにした解説。\n目的と結論\nGreenlight では、Scheduler (Closed Source) が Node 管理の中心にあり、UserClient (with integrated Signer/HSM) が Self-Hosted 環境で秘密鍵を保持する構造をとる。結論として、UserClient 側が鍵操作を制御しつつ、Greenlight 側の Scheduler が Node (CLN) を起動・管理する。これにより、秘密鍵をローカルで保持したまま Node をリモートで稼働させる運用が可能となる。\n全体構造 以下の図に示すように、UserClient (with integrated Signer/HSM) は自前の環境 (Self-Hosted) で動作する。一方、Scheduler は Greenlight が管理し、CLN (c-lightning+plugin) も Greenlight Hosted 環境で稼働する。UserClient は Scheduler に対して Manage API call を行い、Node に対する操作は Scheduler が CLN を経由して実行する。Signer/HSM は秘密鍵をローカルで保持し、署名要求のみを受け付ける。\n(Self-Hosted) (Greenlight Hosted) +-----------------------------------+ (Manage API call) +----------------------------+ | UserClient (with integrated | --------------------\u003e | Scheduler (Closed Source) | | Signer / HSM) | +-------------+--------------+ +-----------------------------------+ | | (Node management) | v | +------------------------+ |-----------------------\u003e |CLN (c-lightning+plugin)| +-----------+------------+ ノード登録とスケジューリングフロー チャレンジ発行 (GetChallenge) スコープ (REGISTER や RECOVER) と node_id を指定し、Scheduler に GetChallenge をコールする。 Scheduler は一度きり有効な challenge を生成し、ChallengeResponse に含めて返す。 Register / Recover クライアントは challenge を秘密鍵で署名し、node_id、network、CSR などと共に送信する。 Scheduler は署名検証後にノード所有権を確認し、mTLS のための device_cert と device_key を発行する。 Register は新規発行、Recover は既存ノードの証明書再発行となる。 Schedule / GetNodeInfo クライアントは Schedule を呼び出し、ノード起動をリクエストする。 Scheduler は CLN を割り当て、grpc_uri など接続情報を返す。 すでに起動済みの場合、GetNodeInfo で接続情報を取得可能である。 接続・操作 クライアントは取得した device_cert と device_key を用い、mTLS で CLN (node) に接続する。 支払いやチャネル操作などの RPC 呼び出しを行う。 署名が必要な場合、CLN は Signer (HSM) へ HsmRequest を送信し、秘密鍵を外部に渡さずに署名のみを実行する。 Signer フロー (HSMRequest / HsmService) CLN は秘密鍵が必要なとき、Node Service の StreamHsmRequests を用いて外部サイナー (Signer/HSM) へ HsmRequest を通知する。Signer はローカルで署名を実施し、HsmResponse で返す。具体的な流れは以下の通りである。\nノード (CLN) 側で署名が必要になる StreamHsmRequests によって署名リクエスト (HsmRequest) が Signer に飛ぶ Signer は秘密鍵で署名し、HsmResponse に署名データ (raw) を格納して返す CLN は署名済みトランザクションを使って on-chain 操作などを進行する CLN との連携 Scheduler がスケジューリングリクエストを受けると、内部で以下を行う。\nScheduler が起動要求を受理する。 該当する CLN インスタンスを確保し、node_id とネットワーク情報を対応付ける。 署名が必要な場面で、CLN は Node サービスを通じてサイナーに HsmRequest を送る。 サイナーが HsmResponse で署名済みバイト列を返す。 CLN は得られた署名を使ってトランザクションを送信する。 以下はノード登録と署名のやり取りを含むシーケンス図である。\nsequenceDiagram participant Client as Client participant Scheduler as Scheduler participant Node as Node (CLN) participant Signer as Signer/HSM Client-\u003e\u003eScheduler: GetChallenge(scope=REGISTER, node_id) Scheduler--\u003e\u003eClient: ChallengeResponse(challenge) Client-\u003e\u003eScheduler: Register(署名付きchallenge, CSR...) Scheduler--\u003e\u003eClient: RegistrationResponse(device_cert, device_key) note over Client,Scheduler: 認証情報を取得後、\nnode_id単位で操作可能 Client-\u003e\u003eScheduler: Schedule(node_id) Scheduler--\u003e\u003eNode: CLNインスタンス起動 Scheduler--\u003e\u003eClient: NodeInfoResponse(grpc_uri) note over Scheduler,Node: ノードを起動済みなら\nGetNodeInfoで取得 Client-\u003e\u003eNode: (mTLS認証) PayRequest, FundChannel 等 Node--\u003e\u003eSigner: HsmRequest(署名要求) Signer--\u003e\u003eNode: HsmResponse(署名済みraw) note over Node: 署名済みTXをCLNが送信し、\nネットワークで処理を実行 Node--\u003e\u003eClient: 操作結果 mTLS と HSM の詳細 mTLS の目的と構造 mTLS (mutual TLS) は、Server・Client が互いに証明書を提示して正当性を認証し合う。Greenlight では初回アクセス時に “NOBODY” 証明書でレジストレーションを行い、Register/Recover 成功後にノード専用のデバイス証明書を取得する。この仕組みにより、誤ったクライアントが他人のノードを操作することを防げる。\nsequenceDiagram participant Client(Nobody) as Client (TLS:Nobody) participant Scheduler as Scheduler Service participant Signer as Local Signer Client(Nobody)-\u003e\u003eScheduler: GetChallenge(scope=REGISTER, node_id) Scheduler--\u003e\u003eClient(Nobody): ChallengeResponse(challenge) note over Client(Nobody): 認証不要で呼べるのは\nRegister/Recover関連のみ Client(Nobody)-\u003e\u003eSigner: challenge署名を依頼 Signer--\u003e\u003eClient(Nobody): 署名付きchallenge Client(Nobody)-\u003e\u003eScheduler: Register(署名付きchallenge, CSR) Scheduler--\u003e\u003eClient(Nobody): device_cert, device_key note over Client(Nobody): node専用 cert/keyを取得し\nTlsConfig.identity()でアップグレード HSM (Signer) の必要性 on-chain での送金やチャネル開閉において、秘密鍵署名が必須となる。CLN が秘密鍵を直接保有しないため、Signer/HSM が外部署名を行う設計で鍵を安全に守る。Scheduler はノードの起動やポリシー管理を行い、Signer は鍵管理アプリとして署名のみ担当する。\nHSM サインフロー: CLN→Signer sequenceDiagram participant Node(CLN) as Node (CLN) participant Signer as Local Signer(HSM) participant TLS as TlsConfig Node(CLN)-\u003e\u003eSigner: HsmRequest(署名対象raw) Signer-\u003e\u003eSigner: 内部ポリシーで確認し、秘密鍵で署名 Signer--\u003e\u003eNode(CLN): HsmResponse(署名済みraw) note over Node(CLN): 得られた署名でTXを作成し、\nネットワーク送信 Pairing の詳細 Pairingサービス (scheduler.proto) Pairing (ペアリング) は新規デバイスがノード操作権限を取得するプロセスである。既存デバイスの承認を経て、新規デバイスに TLS 証明書が発行される。\nPairDevice: 新規デバイスは device_id, CSR, device_name, restrictions などを送信。 GetPairingData: 既存デバイスが新規デバイスのペアリング情報を確認。 ApprovePairing: 既存デバイスが最終承認し、サーバが新規デバイス向けに証明書を発行する。 sequenceDiagram participant NewDevice as New Device participant OldDevice as Old Device (signer) participant Scheduler as Scheduler participant SignerRequests as SignerRequestsStream NewDevice-\u003e\u003eScheduler: PairDevice(PairDeviceRequest) note over NewDevice,Scheduler: 新規デバイスがペアリング用セッションを作成 OldDevice-\u003e\u003eScheduler: GetPairingData(GetPairingDataRequest) Scheduler--\u003e\u003eOldDevice: GetPairingDataResponse(device_id, description, restrictions, ...) note over OldDevice: 実際にユーザが確認し、承認を判断 OldDevice-\u003e\u003eScheduler: ApprovePairing(ApprovePairingRequest) note over Scheduler: 承認内容を\nSignerRequestsStreamへ通知 Scheduler--\u003e\u003eSignerRequests: SignerRequest(ApprovePairingRequest) SignerRequests--\u003e\u003eScheduler: SignerResponse(承認成功または拒否) note over Scheduler: 承認完了後に\n新規デバイスへTLS証明書を発行 Scheduler--\u003e\u003eNewDevice: PairDeviceResponse(device_cert, device_key, rune, creds) note over NewDevice: ノード操作権限を\n新規デバイスで取得 まとめ 以上のとおり、UserClient (with integrated Signer/HSM) はセルフホストされ、ユーザが秘密鍵を常に制御する。一方、Scheduler (Closed Source) は Greenlight 側で稼働し、Node (CLN) の起動や管理を統括する。この構造により、秘密鍵保護とリモート運用を両立させつつ、ペアリング機能によってデバイス間で安全に権限を移管できる。\n","wordCount":"461","inLanguage":"en","datePublished":"2025-03-19T11:07:52+09:00","dateModified":"2025-03-19T11:07:52+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/"},"publisher":{"@type":"Organization","name":"blog","logo":{"@type":"ImageObject","url":"https://yusukeshimizu.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yusukeshimizu.github.io/blog/ accesskey=h title="blog (Alt + H)">blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Greenlight SchedulerとSignerの関係性</h1><div class=post-meta><span title='2025-03-19 11:07:52 +0900 +0900'>March 19, 2025</span></div></header><div class=post-content><p><a href=https://github.com/Blockstream/greenlight/tree/adac70212c70119cc7e7174a742133e14dcdea0a/libs/proto/glclient>greenlight proto</a> をベースにした解説。</p><p><strong>目的と結論</strong><br>Greenlight では、Scheduler (Closed Source) が Node 管理の中心にあり、UserClient (with integrated Signer/HSM) が Self-Hosted 環境で秘密鍵を保持する構造をとる。結論として、UserClient 側が鍵操作を制御しつつ、Greenlight 側の Scheduler が Node (CLN) を起動・管理する。これにより、秘密鍵をローカルで保持したまま Node をリモートで稼働させる運用が可能となる。</p><hr><h2 id=全体構造>全体構造<a hidden class=anchor aria-hidden=true href=#全体構造>#</a></h2><p>以下の図に示すように、UserClient (with integrated Signer/HSM) は自前の環境 (Self-Hosted) で動作する。一方、Scheduler は Greenlight が管理し、CLN (c-lightning+plugin) も Greenlight Hosted 環境で稼働する。UserClient は Scheduler に対して Manage API call を行い、Node に対する操作は Scheduler が CLN を経由して実行する。Signer/HSM は秘密鍵をローカルで保持し、署名要求のみを受け付ける。</p><pre tabindex=0><code>(Self-Hosted)                                                    (Greenlight Hosted)
  +-----------------------------------+   (Manage API call)   +----------------------------+
  | UserClient (with integrated       | --------------------&gt; | Scheduler (Closed Source)  |
  | Signer / HSM)                     |                       +-------------+--------------+
  +-----------------------------------+                                     |
                                     |                              (Node management)
                                     |                                      v
                                     |                           +------------------------+
                                     |-----------------------&gt;   |CLN (c-lightning+plugin)|
                                                                 +-----------+------------+
</code></pre><hr><h2 id=ノード登録とスケジューリングフロー>ノード登録とスケジューリングフロー<a hidden class=anchor aria-hidden=true href=#ノード登録とスケジューリングフロー>#</a></h2><h3 id=チャレンジ発行-getchallenge>チャレンジ発行 (GetChallenge)<a hidden class=anchor aria-hidden=true href=#チャレンジ発行-getchallenge>#</a></h3><ol><li>スコープ (REGISTER や RECOVER) と node_id を指定し、Scheduler に GetChallenge をコールする。</li><li>Scheduler は一度きり有効な challenge を生成し、ChallengeResponse に含めて返す。</li></ol><h3 id=register--recover>Register / Recover<a hidden class=anchor aria-hidden=true href=#register--recover>#</a></h3><ol><li>クライアントは challenge を秘密鍵で署名し、node_id、network、CSR などと共に送信する。</li><li>Scheduler は署名検証後にノード所有権を確認し、mTLS のための device_cert と device_key を発行する。</li><li>Register は新規発行、Recover は既存ノードの証明書再発行となる。</li></ol><h3 id=schedule--getnodeinfo>Schedule / GetNodeInfo<a hidden class=anchor aria-hidden=true href=#schedule--getnodeinfo>#</a></h3><ol><li>クライアントは Schedule を呼び出し、ノード起動をリクエストする。</li><li>Scheduler は CLN を割り当て、grpc_uri など接続情報を返す。</li><li>すでに起動済みの場合、GetNodeInfo で接続情報を取得可能である。</li></ol><h3 id=接続操作>接続・操作<a hidden class=anchor aria-hidden=true href=#接続操作>#</a></h3><ol><li>クライアントは取得した device_cert と device_key を用い、mTLS で CLN (node) に接続する。</li><li>支払いやチャネル操作などの RPC 呼び出しを行う。</li><li>署名が必要な場合、CLN は Signer (HSM) へ HsmRequest を送信し、秘密鍵を外部に渡さずに署名のみを実行する。</li></ol><hr><h2 id=signer-フロー-hsmrequest--hsmservice>Signer フロー (HSMRequest / HsmService)<a hidden class=anchor aria-hidden=true href=#signer-フロー-hsmrequest--hsmservice>#</a></h2><p>CLN は秘密鍵が必要なとき、Node Service の StreamHsmRequests を用いて外部サイナー (Signer/HSM) へ HsmRequest を通知する。Signer はローカルで署名を実施し、HsmResponse で返す。具体的な流れは以下の通りである。</p><ol><li><strong>ノード (CLN) 側で署名が必要になる</strong></li><li><strong>StreamHsmRequests によって署名リクエスト (HsmRequest) が Signer に飛ぶ</strong></li><li><strong>Signer は秘密鍵で署名し、HsmResponse に署名データ (raw) を格納して返す</strong></li><li><strong>CLN は署名済みトランザクションを使って on-chain 操作などを進行する</strong></li></ol><hr><h2 id=cln-との連携>CLN との連携<a hidden class=anchor aria-hidden=true href=#cln-との連携>#</a></h2><p>Scheduler がスケジューリングリクエストを受けると、内部で以下を行う。</p><ol><li>Scheduler が起動要求を受理する。</li><li>該当する CLN インスタンスを確保し、node_id とネットワーク情報を対応付ける。</li><li>署名が必要な場面で、CLN は Node サービスを通じてサイナーに HsmRequest を送る。</li><li>サイナーが HsmResponse で署名済みバイト列を返す。</li><li>CLN は得られた署名を使ってトランザクションを送信する。</li></ol><hr><p>以下はノード登録と署名のやり取りを含むシーケンス図である。</p><pre class=mermaid>sequenceDiagram
    participant Client as Client
    participant Scheduler as Scheduler
    participant Node as Node (CLN)
    participant Signer as Signer/HSM
    Client-&gt;&gt;Scheduler: GetChallenge(scope=REGISTER, node_id)
    Scheduler--&gt;&gt;Client: ChallengeResponse(challenge)
    Client-&gt;&gt;Scheduler: Register(署名付きchallenge, CSR...)
    Scheduler--&gt;&gt;Client: RegistrationResponse(device_cert, device_key)
    note over Client,Scheduler: 認証情報を取得後、&lt;br&gt;node_id単位で操作可能
    Client-&gt;&gt;Scheduler: Schedule(node_id)
    Scheduler--&gt;&gt;Node: CLNインスタンス起動
    Scheduler--&gt;&gt;Client: NodeInfoResponse(grpc_uri)
    note over Scheduler,Node: ノードを起動済みなら&lt;br&gt;GetNodeInfoで取得
    Client-&gt;&gt;Node: (mTLS認証) PayRequest, FundChannel 等
    Node--&gt;&gt;Signer: HsmRequest(署名要求)
    Signer--&gt;&gt;Node: HsmResponse(署名済みraw)
    note over Node: 署名済みTXをCLNが送信し、&lt;br&gt;ネットワークで処理を実行
    Node--&gt;&gt;Client: 操作結果
  </pre><hr><h2 id=mtls-と-hsm-の詳細>mTLS と HSM の詳細<a hidden class=anchor aria-hidden=true href=#mtls-と-hsm-の詳細>#</a></h2><h3 id=mtls-の目的と構造>mTLS の目的と構造<a hidden class=anchor aria-hidden=true href=#mtls-の目的と構造>#</a></h3><p>mTLS (mutual TLS) は、Server・Client が互いに証明書を提示して正当性を認証し合う。Greenlight では初回アクセス時に “NOBODY” 証明書でレジストレーションを行い、Register/Recover 成功後にノード専用のデバイス証明書を取得する。この仕組みにより、誤ったクライアントが他人のノードを操作することを防げる。</p><pre class=mermaid>sequenceDiagram
    participant Client(Nobody) as Client (TLS:Nobody)
    participant Scheduler as Scheduler Service
    participant Signer as Local Signer

    Client(Nobody)-&gt;&gt;Scheduler: GetChallenge(scope=REGISTER, node_id)
    Scheduler--&gt;&gt;Client(Nobody): ChallengeResponse(challenge)

    note over Client(Nobody): 認証不要で呼べるのは&lt;br&gt;Register/Recover関連のみ

    Client(Nobody)-&gt;&gt;Signer: challenge署名を依頼
    Signer--&gt;&gt;Client(Nobody): 署名付きchallenge

    Client(Nobody)-&gt;&gt;Scheduler: Register(署名付きchallenge, CSR)
    Scheduler--&gt;&gt;Client(Nobody): device_cert, device_key

    note over Client(Nobody): node専用 cert/keyを取得し&lt;br&gt;TlsConfig.identity()でアップグレード
  </pre><h3 id=hsm-signer-の必要性>HSM (Signer) の必要性<a hidden class=anchor aria-hidden=true href=#hsm-signer-の必要性>#</a></h3><p>on-chain での送金やチャネル開閉において、秘密鍵署名が必須となる。CLN が秘密鍵を直接保有しないため、Signer/HSM が外部署名を行う設計で鍵を安全に守る。Scheduler はノードの起動やポリシー管理を行い、Signer は鍵管理アプリとして署名のみ担当する。</p><h4 id=hsm-サインフロー-clnsigner>HSM サインフロー: CLN→Signer<a hidden class=anchor aria-hidden=true href=#hsm-サインフロー-clnsigner>#</a></h4><pre class=mermaid>sequenceDiagram
    participant Node(CLN) as Node (CLN)
    participant Signer as Local Signer(HSM)
    participant TLS as TlsConfig

    Node(CLN)-&gt;&gt;Signer: HsmRequest(署名対象raw)
    Signer-&gt;&gt;Signer: 内部ポリシーで確認し、秘密鍵で署名
    Signer--&gt;&gt;Node(CLN): HsmResponse(署名済みraw)
    note over Node(CLN): 得られた署名でTXを作成し、&lt;br&gt;ネットワーク送信
  </pre><hr><h2 id=pairing-の詳細>Pairing の詳細<a hidden class=anchor aria-hidden=true href=#pairing-の詳細>#</a></h2><h3 id=pairingサービス-schedulerproto>Pairingサービス (scheduler.proto)<a hidden class=anchor aria-hidden=true href=#pairingサービス-schedulerproto>#</a></h3><p>Pairing (ペアリング) は新規デバイスがノード操作権限を取得するプロセスである。既存デバイスの承認を経て、新規デバイスに TLS 証明書が発行される。</p><ol><li><strong>PairDevice</strong>: 新規デバイスは device_id, CSR, device_name, restrictions などを送信。</li><li><strong>GetPairingData</strong>: 既存デバイスが新規デバイスのペアリング情報を確認。</li><li><strong>ApprovePairing</strong>: 既存デバイスが最終承認し、サーバが新規デバイス向けに証明書を発行する。</li></ol><pre class=mermaid>sequenceDiagram
    participant NewDevice as New Device
    participant OldDevice as Old Device (signer)
    participant Scheduler as Scheduler
    participant SignerRequests as SignerRequestsStream
    NewDevice-&gt;&gt;Scheduler: PairDevice(PairDeviceRequest)
    note over NewDevice,Scheduler: 新規デバイスがペアリング用セッションを作成
    OldDevice-&gt;&gt;Scheduler: GetPairingData(GetPairingDataRequest)
    Scheduler--&gt;&gt;OldDevice: GetPairingDataResponse(device_id, description, restrictions, ...)
    note over OldDevice: 実際にユーザが確認し、承認を判断
    OldDevice-&gt;&gt;Scheduler: ApprovePairing(ApprovePairingRequest)
    note over Scheduler: 承認内容を&lt;br&gt;SignerRequestsStreamへ通知
    Scheduler--&gt;&gt;SignerRequests: SignerRequest(ApprovePairingRequest)
    SignerRequests--&gt;&gt;Scheduler: SignerResponse(承認成功または拒否)
    note over Scheduler: 承認完了後に&lt;br&gt;新規デバイスへTLS証明書を発行
    Scheduler--&gt;&gt;NewDevice: PairDeviceResponse(device_cert, device_key, rune, creds)
    note over NewDevice: ノード操作権限を&lt;br&gt;新規デバイスで取得
  </pre><hr><h2 id=まとめ>まとめ<a hidden class=anchor aria-hidden=true href=#まとめ>#</a></h2><p>以上のとおり、UserClient (with integrated Signer/HSM) はセルフホストされ、ユーザが秘密鍵を常に制御する。一方、Scheduler (Closed Source) は Greenlight 側で稼働し、Node (CLN) の起動や管理を統括する。この構造により、秘密鍵保護とリモート運用を両立させつつ、ペアリング機能によってデバイス間で安全に権限を移管できる。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yusukeshimizu.github.io/blog/>blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>