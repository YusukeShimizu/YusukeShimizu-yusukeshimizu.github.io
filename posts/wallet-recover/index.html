<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wallet Recover | blog</title>
<meta name=keywords content><meta name=description content="mnemonic seedを保持していれば、ウォレットの残高をリカバリーできる。これは一見不思議だが、実際には無限に生成可能なアドレス（script pubkey）のうち、使用されたものだけを検出し、UTXOを取得する仕組みがあるためである。どのアドレスが使われたかを追跡できるからこそ、seedを頼りに残高を復元できる。
しかし、mnemonic seedを持っているのに残高が正しく復旧しないケースも存在する。また、レガシーSegWit（P2SHアドレス・3xxxx）の潜在的な危険性は誤解を生みやすい。これらを整理するために、btc walletの実装（https://github.com/btcsuite/btcwallet）を例にしながら、BIP0044/49/84/86が規定するHDウォレット構造と、ウォレットのリカバリー方法を示す。
BIPの概要と相互関係
BIP0044、BIP0049、BIP0084、BIP0086はいずれもHDウォレットの「目的（purpose）番号」を定義し、各アドレス形式を区別している。以下、それぞれの要点をまとめる。
BIP44

概要: m/44'/coin_type'/account'/change/address_index の構造を規定する汎用的HDウォレット標準。
用途: レガシーP2PKH（1xxxx）アドレスに広く利用されてきた。複数通貨・複数アカウント管理が可能。
他BIPとの関係: 新しいアドレス形式に対応するBIP49やBIP84などは、このBIP44をベースにpurpose番号を変えて並立利用できる。

BIP49

概要: m/49'/coin_type'/account'/change/address_index を使い、P2WPKH-in-P2SH（3xxxx）アドレスを定義。
目的: 互換性を重視しつつ部分的にSegWitの恩恵（手数料削減など）を得るためのラップドSegWit。
他BIPとの関係: レガシー形式（BIP44）を補完し、新しいネイティブSegWit（BIP84）へ移行する中継的役割を果たす。

BIP84

概要: m/84'/coin_type'/account'/change/address_index の構造を使い、ネイティブSegWit（bech32、bc1q&mldr;）アドレスを定義。
目的: SegWitの機能をフル活用し、より低い手数料やエラー検知の強化を実現。
他BIPとの関係: ラップドSegWit（BIP49）より進んだ純粋なSegWit。Taproot（BIP86）の前段階。

BIP86

概要: m/86'/coin_type'/account'/change/address_index を使い、Taproot（bech32m、bc1p&mldr;）アドレス（単独所有向け）を定義。
目的: Schnorr署名やMASTなどTaprootの恩恵（手数料削減・プライバシー向上）を得る。現時点ではシングルキー中心だが、将来的な拡張も想定。
他BIPとの関係: ネイティブSegWit（BIP84）より先進的なP2TR形態を扱う。purpose番号86を使い、既存形式と衝突しない。

BIP49が「legacy segwit」と呼ばれる理由
BIP49のP2WPKH-in-P2SHアドレス（3xxxx）は見た目が通常のP2SHと同じため、一般に「legacy segwit」とも呼ばれる。P2SHの場合、redeemScriptをユーザ側で保持する必要があるが、BIP49対応ウォレット（例: 多くのハードウェアウォレットなど）を使うなら、redeemScriptを個別にバックアップしなくても済む。
アドレスインデックスとリカバリー
アドレスインデックス（address_index）はウォレットが生成したアドレス数に応じて変化する。復旧時には何番目までアドレスを生成してスキャンするかを決める必要がある。btc walletでは以下のアルゴリズムにより、使用中のアドレスを取りこぼさずに効率的なブロックスキャンを行う。
sequenceDiagram
    participant RM as RecoveryManager
    participant RS as RecoveryState
    participant BRS as BranchRecoveryState
    participant BC as Blockchain

    Note over RM: (Resurrectで<br>既存のアドレス・UTXOを復元)

    loop until 全ブロックスキャン完了
        RM->BC: 次のブロック(群)取得  
        BC-->RM: BlockBatch返却  
        RM->RS: State取得  
        RM->>BRS: ExtendHorizon()呼び出し
        alt horizonが不足
            BRS->>BRS: horizonを拡張<br>(nextUnfound + recoveryWindow)
            note right of BRS: 無効インデックス数も考慮
        end
        RM->BC: FilterBlocksRequest(生成済みアドレスを照合)
        BC-->RM: FilterBlocksResponse(発見されたaddrのindex)
        RM->>BRS: ReportFound(index)  
        alt 新しい発見がありnextUnfoundが進む
            BRS->>BRS: horizon再チェック
        end
    end

    Note over RM: 発見された中で最も高いインデックス +<br>recoveryWindow + 無効インデックス数まで生成し続ける
  

Resurrect
既知のアドレスやUTXOを RecoveryState に登録し、初期状態をセットする。
ExtendHorizon
nextUnfound + recoveryWindow (+ 無効インデックス数) までアドレスを導出・監視対象に加えておき、取りこぼしを防ぐ。
FilterBlocks
実際にブロックをスキャンし、高いインデックスのアドレスが見つかったら ReportFound で更新し、さらに horizon を見直す。
最終的に
最も高いインデックス + recoveryWindow + 無効インデックス数まで検査し、使われている可能性のあるアドレスを漏れなく拾う。


mnemonic seedさえあれば複数のアドレス形式（P2PKH、P2WPKH-in-P2SH、P2WPKH、Taprootなど）をまとめて手堅くリカバリーできる。目的番号（purpose）を切り替えながら、ウォレットは無数に生成しうるアドレスのうち実使用されたものを判別して残高を復元する。"><meta name=author content><link rel=canonical href=https://yusukeshimizu.github.io/blog/posts/wallet-recover/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://yusukeshimizu.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yusukeshimizu.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yusukeshimizu.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://yusukeshimizu.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://yusukeshimizu.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yusukeshimizu.github.io/blog/posts/wallet-recover/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const elementCode=".mermaid",loadMermaid=function(e){mermaid.initialize({theme:e}),mermaid.init({theme:e},document.querySelectorAll(elementCode))},saveOriginalData=function(){return new Promise((e,t)=>{try{var n=document.querySelectorAll(elementCode),s=n.length;n.forEach(t=>{t.setAttribute("data-original-code",t.innerHTML),s--,s==0&&e()})}catch(e){t(e)}})},resetProcessed=function(){return new Promise((e,t)=>{try{var n=document.querySelectorAll(elementCode),s=n.length;n.forEach(t=>{t.getAttribute("data-original-code")!=null&&(t.removeAttribute("data-processed"),t.innerHTML=t.getAttribute("data-original-code")),s--,s==0&&e()})}catch(e){t(e)}})};saveOriginalData().catch(console.error);let statusTheme=localStorage.getItem("pref-theme");statusTheme=="dark"&&resetProcessed().then(loadMermaid("dark")).catch(console.error),statusTheme=="light"&&resetProcessed().then(loadMermaid("neutral")).catch(console.error),document.getElementById("theme-toggle").addEventListener("click",()=>{resetProcessed().then(loadMermaid(mermaid.mermaidAPI.getConfig().theme=="neutral"?"dark":"neutral")).catch(console.error)})</script><meta property="og:url" content="https://yusukeshimizu.github.io/blog/posts/wallet-recover/"><meta property="og:site_name" content="blog"><meta property="og:title" content="Wallet Recover"><meta property="og:description" content="mnemonic seedを保持していれば、ウォレットの残高をリカバリーできる。これは一見不思議だが、実際には無限に生成可能なアドレス（script pubkey）のうち、使用されたものだけを検出し、UTXOを取得する仕組みがあるためである。どのアドレスが使われたかを追跡できるからこそ、seedを頼りに残高を復元できる。
しかし、mnemonic seedを持っているのに残高が正しく復旧しないケースも存在する。また、レガシーSegWit（P2SHアドレス・3xxxx）の潜在的な危険性は誤解を生みやすい。これらを整理するために、btc walletの実装（https://github.com/btcsuite/btcwallet）を例にしながら、BIP0044/49/84/86が規定するHDウォレット構造と、ウォレットのリカバリー方法を示す。
BIPの概要と相互関係 BIP0044、BIP0049、BIP0084、BIP0086はいずれもHDウォレットの「目的（purpose）番号」を定義し、各アドレス形式を区別している。以下、それぞれの要点をまとめる。
BIP44 概要: m/44'/coin_type'/account'/change/address_index の構造を規定する汎用的HDウォレット標準。 用途: レガシーP2PKH（1xxxx）アドレスに広く利用されてきた。複数通貨・複数アカウント管理が可能。 他BIPとの関係: 新しいアドレス形式に対応するBIP49やBIP84などは、このBIP44をベースにpurpose番号を変えて並立利用できる。 BIP49 概要: m/49'/coin_type'/account'/change/address_index を使い、P2WPKH-in-P2SH（3xxxx）アドレスを定義。 目的: 互換性を重視しつつ部分的にSegWitの恩恵（手数料削減など）を得るためのラップドSegWit。 他BIPとの関係: レガシー形式（BIP44）を補完し、新しいネイティブSegWit（BIP84）へ移行する中継的役割を果たす。 BIP84 概要: m/84'/coin_type'/account'/change/address_index の構造を使い、ネイティブSegWit（bech32、bc1q…）アドレスを定義。 目的: SegWitの機能をフル活用し、より低い手数料やエラー検知の強化を実現。 他BIPとの関係: ラップドSegWit（BIP49）より進んだ純粋なSegWit。Taproot（BIP86）の前段階。 BIP86 概要: m/86'/coin_type'/account'/change/address_index を使い、Taproot（bech32m、bc1p…）アドレス（単独所有向け）を定義。 目的: Schnorr署名やMASTなどTaprootの恩恵（手数料削減・プライバシー向上）を得る。現時点ではシングルキー中心だが、将来的な拡張も想定。 他BIPとの関係: ネイティブSegWit（BIP84）より先進的なP2TR形態を扱う。purpose番号86を使い、既存形式と衝突しない。 BIP49が「legacy segwit」と呼ばれる理由 BIP49のP2WPKH-in-P2SHアドレス（3xxxx）は見た目が通常のP2SHと同じため、一般に「legacy segwit」とも呼ばれる。P2SHの場合、redeemScriptをユーザ側で保持する必要があるが、BIP49対応ウォレット（例: 多くのハードウェアウォレットなど）を使うなら、redeemScriptを個別にバックアップしなくても済む。
アドレスインデックスとリカバリー アドレスインデックス（address_index）はウォレットが生成したアドレス数に応じて変化する。復旧時には何番目までアドレスを生成してスキャンするかを決める必要がある。btc walletでは以下のアルゴリズムにより、使用中のアドレスを取りこぼさずに効率的なブロックスキャンを行う。
sequenceDiagram participant RM as RecoveryManager participant RS as RecoveryState participant BRS as BranchRecoveryState participant BC as Blockchain Note over RM: (Resurrectで<br>既存のアドレス・UTXOを復元) loop until 全ブロックスキャン完了 RM->BC: 次のブロック(群)取得 BC-->RM: BlockBatch返却 RM->RS: State取得 RM->>BRS: ExtendHorizon()呼び出し alt horizonが不足 BRS->>BRS: horizonを拡張<br>(nextUnfound + recoveryWindow) note right of BRS: 無効インデックス数も考慮 end RM->BC: FilterBlocksRequest(生成済みアドレスを照合) BC-->RM: FilterBlocksResponse(発見されたaddrのindex) RM->>BRS: ReportFound(index) alt 新しい発見がありnextUnfoundが進む BRS->>BRS: horizon再チェック end end Note over RM: 発見された中で最も高いインデックス +<br>recoveryWindow + 無効インデックス数まで生成し続ける Resurrect
既知のアドレスやUTXOを RecoveryState に登録し、初期状態をセットする。 ExtendHorizon
nextUnfound + recoveryWindow (+ 無効インデックス数) までアドレスを導出・監視対象に加えておき、取りこぼしを防ぐ。 FilterBlocks
実際にブロックをスキャンし、高いインデックスのアドレスが見つかったら ReportFound で更新し、さらに horizon を見直す。 最終的に
最も高いインデックス + recoveryWindow + 無効インデックス数まで検査し、使われている可能性のあるアドレスを漏れなく拾う。 mnemonic seedさえあれば複数のアドレス形式（P2PKH、P2WPKH-in-P2SH、P2WPKH、Taprootなど）をまとめて手堅くリカバリーできる。目的番号（purpose）を切り替えながら、ウォレットは無数に生成しうるアドレスのうち実使用されたものを判別して残高を復元する。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-27T11:34:54+09:00"><meta property="article:modified_time" content="2025-03-27T11:34:54+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Wallet Recover"><meta name=twitter:description content="mnemonic seedを保持していれば、ウォレットの残高をリカバリーできる。これは一見不思議だが、実際には無限に生成可能なアドレス（script pubkey）のうち、使用されたものだけを検出し、UTXOを取得する仕組みがあるためである。どのアドレスが使われたかを追跡できるからこそ、seedを頼りに残高を復元できる。
しかし、mnemonic seedを持っているのに残高が正しく復旧しないケースも存在する。また、レガシーSegWit（P2SHアドレス・3xxxx）の潜在的な危険性は誤解を生みやすい。これらを整理するために、btc walletの実装（https://github.com/btcsuite/btcwallet）を例にしながら、BIP0044/49/84/86が規定するHDウォレット構造と、ウォレットのリカバリー方法を示す。
BIPの概要と相互関係
BIP0044、BIP0049、BIP0084、BIP0086はいずれもHDウォレットの「目的（purpose）番号」を定義し、各アドレス形式を区別している。以下、それぞれの要点をまとめる。
BIP44

概要: m/44'/coin_type'/account'/change/address_index の構造を規定する汎用的HDウォレット標準。
用途: レガシーP2PKH（1xxxx）アドレスに広く利用されてきた。複数通貨・複数アカウント管理が可能。
他BIPとの関係: 新しいアドレス形式に対応するBIP49やBIP84などは、このBIP44をベースにpurpose番号を変えて並立利用できる。

BIP49

概要: m/49'/coin_type'/account'/change/address_index を使い、P2WPKH-in-P2SH（3xxxx）アドレスを定義。
目的: 互換性を重視しつつ部分的にSegWitの恩恵（手数料削減など）を得るためのラップドSegWit。
他BIPとの関係: レガシー形式（BIP44）を補完し、新しいネイティブSegWit（BIP84）へ移行する中継的役割を果たす。

BIP84

概要: m/84'/coin_type'/account'/change/address_index の構造を使い、ネイティブSegWit（bech32、bc1q&mldr;）アドレスを定義。
目的: SegWitの機能をフル活用し、より低い手数料やエラー検知の強化を実現。
他BIPとの関係: ラップドSegWit（BIP49）より進んだ純粋なSegWit。Taproot（BIP86）の前段階。

BIP86

概要: m/86'/coin_type'/account'/change/address_index を使い、Taproot（bech32m、bc1p&mldr;）アドレス（単独所有向け）を定義。
目的: Schnorr署名やMASTなどTaprootの恩恵（手数料削減・プライバシー向上）を得る。現時点ではシングルキー中心だが、将来的な拡張も想定。
他BIPとの関係: ネイティブSegWit（BIP84）より先進的なP2TR形態を扱う。purpose番号86を使い、既存形式と衝突しない。

BIP49が「legacy segwit」と呼ばれる理由
BIP49のP2WPKH-in-P2SHアドレス（3xxxx）は見た目が通常のP2SHと同じため、一般に「legacy segwit」とも呼ばれる。P2SHの場合、redeemScriptをユーザ側で保持する必要があるが、BIP49対応ウォレット（例: 多くのハードウェアウォレットなど）を使うなら、redeemScriptを個別にバックアップしなくても済む。
アドレスインデックスとリカバリー
アドレスインデックス（address_index）はウォレットが生成したアドレス数に応じて変化する。復旧時には何番目までアドレスを生成してスキャンするかを決める必要がある。btc walletでは以下のアルゴリズムにより、使用中のアドレスを取りこぼさずに効率的なブロックスキャンを行う。
sequenceDiagram
    participant RM as RecoveryManager
    participant RS as RecoveryState
    participant BRS as BranchRecoveryState
    participant BC as Blockchain

    Note over RM: (Resurrectで<br>既存のアドレス・UTXOを復元)

    loop until 全ブロックスキャン完了
        RM->BC: 次のブロック(群)取得  
        BC-->RM: BlockBatch返却  
        RM->RS: State取得  
        RM->>BRS: ExtendHorizon()呼び出し
        alt horizonが不足
            BRS->>BRS: horizonを拡張<br>(nextUnfound + recoveryWindow)
            note right of BRS: 無効インデックス数も考慮
        end
        RM->BC: FilterBlocksRequest(生成済みアドレスを照合)
        BC-->RM: FilterBlocksResponse(発見されたaddrのindex)
        RM->>BRS: ReportFound(index)  
        alt 新しい発見がありnextUnfoundが進む
            BRS->>BRS: horizon再チェック
        end
    end

    Note over RM: 発見された中で最も高いインデックス +<br>recoveryWindow + 無効インデックス数まで生成し続ける
  

Resurrect
既知のアドレスやUTXOを RecoveryState に登録し、初期状態をセットする。
ExtendHorizon
nextUnfound + recoveryWindow (+ 無効インデックス数) までアドレスを導出・監視対象に加えておき、取りこぼしを防ぐ。
FilterBlocks
実際にブロックをスキャンし、高いインデックスのアドレスが見つかったら ReportFound で更新し、さらに horizon を見直す。
最終的に
最も高いインデックス + recoveryWindow + 無効インデックス数まで検査し、使われている可能性のあるアドレスを漏れなく拾う。


mnemonic seedさえあれば複数のアドレス形式（P2PKH、P2WPKH-in-P2SH、P2WPKH、Taprootなど）をまとめて手堅くリカバリーできる。目的番号（purpose）を切り替えながら、ウォレットは無数に生成しうるアドレスのうち実使用されたものを判別して残高を復元する。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yusukeshimizu.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Wallet Recover","item":"https://yusukeshimizu.github.io/blog/posts/wallet-recover/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Wallet Recover","name":"Wallet Recover","description":"mnemonic seedを保持していれば、ウォレットの残高をリカバリーできる。これは一見不思議だが、実際には無限に生成可能なアドレス（script pubkey）のうち、使用されたものだけを検出し、UTXOを取得する仕組みがあるためである。どのアドレスが使われたかを追跡できるからこそ、seedを頼りに残高を復元できる。\nしかし、mnemonic seedを持っているのに残高が正しく復旧しないケースも存在する。また、レガシーSegWit（P2SHアドレス・3xxxx）の潜在的な危険性は誤解を生みやすい。これらを整理するために、btc walletの実装（https://github.com/btcsuite/btcwallet）を例にしながら、BIP0044/49/84/86が規定するHDウォレット構造と、ウォレットのリカバリー方法を示す。\nBIPの概要と相互関係 BIP0044、BIP0049、BIP0084、BIP0086はいずれもHDウォレットの「目的（purpose）番号」を定義し、各アドレス形式を区別している。以下、それぞれの要点をまとめる。\nBIP44 概要: m/44'/coin_type'/account'/change/address_index の構造を規定する汎用的HDウォレット標準。 用途: レガシーP2PKH（1xxxx）アドレスに広く利用されてきた。複数通貨・複数アカウント管理が可能。 他BIPとの関係: 新しいアドレス形式に対応するBIP49やBIP84などは、このBIP44をベースにpurpose番号を変えて並立利用できる。 BIP49 概要: m/49'/coin_type'/account'/change/address_index を使い、P2WPKH-in-P2SH（3xxxx）アドレスを定義。 目的: 互換性を重視しつつ部分的にSegWitの恩恵（手数料削減など）を得るためのラップドSegWit。 他BIPとの関係: レガシー形式（BIP44）を補完し、新しいネイティブSegWit（BIP84）へ移行する中継的役割を果たす。 BIP84 概要: m/84'/coin_type'/account'/change/address_index の構造を使い、ネイティブSegWit（bech32、bc1q\u0026hellip;）アドレスを定義。 目的: SegWitの機能をフル活用し、より低い手数料やエラー検知の強化を実現。 他BIPとの関係: ラップドSegWit（BIP49）より進んだ純粋なSegWit。Taproot（BIP86）の前段階。 BIP86 概要: m/86'/coin_type'/account'/change/address_index を使い、Taproot（bech32m、bc1p\u0026hellip;）アドレス（単独所有向け）を定義。 目的: Schnorr署名やMASTなどTaprootの恩恵（手数料削減・プライバシー向上）を得る。現時点ではシングルキー中心だが、将来的な拡張も想定。 他BIPとの関係: ネイティブSegWit（BIP84）より先進的なP2TR形態を扱う。purpose番号86を使い、既存形式と衝突しない。 BIP49が「legacy segwit」と呼ばれる理由 BIP49のP2WPKH-in-P2SHアドレス（3xxxx）は見た目が通常のP2SHと同じため、一般に「legacy segwit」とも呼ばれる。P2SHの場合、redeemScriptをユーザ側で保持する必要があるが、BIP49対応ウォレット（例: 多くのハードウェアウォレットなど）を使うなら、redeemScriptを個別にバックアップしなくても済む。\nアドレスインデックスとリカバリー アドレスインデックス（address_index）はウォレットが生成したアドレス数に応じて変化する。復旧時には何番目までアドレスを生成してスキャンするかを決める必要がある。btc walletでは以下のアルゴリズムにより、使用中のアドレスを取りこぼさずに効率的なブロックスキャンを行う。\nsequenceDiagram participant RM as RecoveryManager participant RS as RecoveryState participant BRS as BranchRecoveryState participant BC as Blockchain Note over RM: (Resurrectで\u0026lt;br\u0026gt;既存のアドレス・UTXOを復元) loop until 全ブロックスキャン完了 RM-\u0026gt;BC: 次のブロック(群)取得 BC--\u0026gt;RM: BlockBatch返却 RM-\u0026gt;RS: State取得 RM-\u0026gt;\u0026gt;BRS: ExtendHorizon()呼び出し alt horizonが不足 BRS-\u0026gt;\u0026gt;BRS: horizonを拡張\u0026lt;br\u0026gt;(nextUnfound + recoveryWindow) note right of BRS: 無効インデックス数も考慮 end RM-\u0026gt;BC: FilterBlocksRequest(生成済みアドレスを照合) BC--\u0026gt;RM: FilterBlocksResponse(発見されたaddrのindex) RM-\u0026gt;\u0026gt;BRS: ReportFound(index) alt 新しい発見がありnextUnfoundが進む BRS-\u0026gt;\u0026gt;BRS: horizon再チェック end end Note over RM: 発見された中で最も高いインデックス +\u0026lt;br\u0026gt;recoveryWindow + 無効インデックス数まで生成し続ける Resurrect\n既知のアドレスやUTXOを RecoveryState に登録し、初期状態をセットする。 ExtendHorizon\nnextUnfound + recoveryWindow (+ 無効インデックス数) までアドレスを導出・監視対象に加えておき、取りこぼしを防ぐ。 FilterBlocks\n実際にブロックをスキャンし、高いインデックスのアドレスが見つかったら ReportFound で更新し、さらに horizon を見直す。 最終的に\n最も高いインデックス + recoveryWindow + 無効インデックス数まで検査し、使われている可能性のあるアドレスを漏れなく拾う。 mnemonic seedさえあれば複数のアドレス形式（P2PKH、P2WPKH-in-P2SH、P2WPKH、Taprootなど）をまとめて手堅くリカバリーできる。目的番号（purpose）を切り替えながら、ウォレットは無数に生成しうるアドレスのうち実使用されたものを判別して残高を復元する。\n","keywords":[],"articleBody":"mnemonic seedを保持していれば、ウォレットの残高をリカバリーできる。これは一見不思議だが、実際には無限に生成可能なアドレス（script pubkey）のうち、使用されたものだけを検出し、UTXOを取得する仕組みがあるためである。どのアドレスが使われたかを追跡できるからこそ、seedを頼りに残高を復元できる。\nしかし、mnemonic seedを持っているのに残高が正しく復旧しないケースも存在する。また、レガシーSegWit（P2SHアドレス・3xxxx）の潜在的な危険性は誤解を生みやすい。これらを整理するために、btc walletの実装（https://github.com/btcsuite/btcwallet）を例にしながら、BIP0044/49/84/86が規定するHDウォレット構造と、ウォレットのリカバリー方法を示す。\nBIPの概要と相互関係 BIP0044、BIP0049、BIP0084、BIP0086はいずれもHDウォレットの「目的（purpose）番号」を定義し、各アドレス形式を区別している。以下、それぞれの要点をまとめる。\nBIP44 概要: m/44'/coin_type'/account'/change/address_index の構造を規定する汎用的HDウォレット標準。 用途: レガシーP2PKH（1xxxx）アドレスに広く利用されてきた。複数通貨・複数アカウント管理が可能。 他BIPとの関係: 新しいアドレス形式に対応するBIP49やBIP84などは、このBIP44をベースにpurpose番号を変えて並立利用できる。 BIP49 概要: m/49'/coin_type'/account'/change/address_index を使い、P2WPKH-in-P2SH（3xxxx）アドレスを定義。 目的: 互換性を重視しつつ部分的にSegWitの恩恵（手数料削減など）を得るためのラップドSegWit。 他BIPとの関係: レガシー形式（BIP44）を補完し、新しいネイティブSegWit（BIP84）へ移行する中継的役割を果たす。 BIP84 概要: m/84'/coin_type'/account'/change/address_index の構造を使い、ネイティブSegWit（bech32、bc1q…）アドレスを定義。 目的: SegWitの機能をフル活用し、より低い手数料やエラー検知の強化を実現。 他BIPとの関係: ラップドSegWit（BIP49）より進んだ純粋なSegWit。Taproot（BIP86）の前段階。 BIP86 概要: m/86'/coin_type'/account'/change/address_index を使い、Taproot（bech32m、bc1p…）アドレス（単独所有向け）を定義。 目的: Schnorr署名やMASTなどTaprootの恩恵（手数料削減・プライバシー向上）を得る。現時点ではシングルキー中心だが、将来的な拡張も想定。 他BIPとの関係: ネイティブSegWit（BIP84）より先進的なP2TR形態を扱う。purpose番号86を使い、既存形式と衝突しない。 BIP49が「legacy segwit」と呼ばれる理由 BIP49のP2WPKH-in-P2SHアドレス（3xxxx）は見た目が通常のP2SHと同じため、一般に「legacy segwit」とも呼ばれる。P2SHの場合、redeemScriptをユーザ側で保持する必要があるが、BIP49対応ウォレット（例: 多くのハードウェアウォレットなど）を使うなら、redeemScriptを個別にバックアップしなくても済む。\nアドレスインデックスとリカバリー アドレスインデックス（address_index）はウォレットが生成したアドレス数に応じて変化する。復旧時には何番目までアドレスを生成してスキャンするかを決める必要がある。btc walletでは以下のアルゴリズムにより、使用中のアドレスを取りこぼさずに効率的なブロックスキャンを行う。\nsequenceDiagram participant RM as RecoveryManager participant RS as RecoveryState participant BRS as BranchRecoveryState participant BC as Blockchain Note over RM: (Resurrectで\n既存のアドレス・UTXOを復元) loop until 全ブロックスキャン完了 RM-\u003eBC: 次のブロック(群)取得 BC--\u003eRM: BlockBatch返却 RM-\u003eRS: State取得 RM-\u003e\u003eBRS: ExtendHorizon()呼び出し alt horizonが不足 BRS-\u003e\u003eBRS: horizonを拡張\n(nextUnfound + recoveryWindow) note right of BRS: 無効インデックス数も考慮 end RM-\u003eBC: FilterBlocksRequest(生成済みアドレスを照合) BC--\u003eRM: FilterBlocksResponse(発見されたaddrのindex) RM-\u003e\u003eBRS: ReportFound(index) alt 新しい発見がありnextUnfoundが進む BRS-\u003e\u003eBRS: horizon再チェック end end Note over RM: 発見された中で最も高いインデックス +\nrecoveryWindow + 無効インデックス数まで生成し続ける Resurrect\n既知のアドレスやUTXOを RecoveryState に登録し、初期状態をセットする。 ExtendHorizon\nnextUnfound + recoveryWindow (+ 無効インデックス数) までアドレスを導出・監視対象に加えておき、取りこぼしを防ぐ。 FilterBlocks\n実際にブロックをスキャンし、高いインデックスのアドレスが見つかったら ReportFound で更新し、さらに horizon を見直す。 最終的に\n最も高いインデックス + recoveryWindow + 無効インデックス数まで検査し、使われている可能性のあるアドレスを漏れなく拾う。 mnemonic seedさえあれば複数のアドレス形式（P2PKH、P2WPKH-in-P2SH、P2WPKH、Taprootなど）をまとめて手堅くリカバリーできる。目的番号（purpose）を切り替えながら、ウォレットは無数に生成しうるアドレスのうち実使用されたものを判別して残高を復元する。\nよって、各ウォレットで使われるHDウォレット構造（BIP44/49/84/86）を正しく守ることが重要である。これらのBIP（Bitcoin Improvement Proposal）は、アドレスを生成するための派生パスを詳細に規定している。これらの規定に従わずに作成された残高は通常の手順では検出できない。\n","wordCount":"139","inLanguage":"en","datePublished":"2025-03-27T11:34:54+09:00","dateModified":"2025-03-27T11:34:54+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://yusukeshimizu.github.io/blog/posts/wallet-recover/"},"publisher":{"@type":"Organization","name":"blog","logo":{"@type":"ImageObject","url":"https://yusukeshimizu.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yusukeshimizu.github.io/blog/ accesskey=h title="blog (Alt + H)">blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Wallet Recover</h1><div class=post-meta><span title='2025-03-27 11:34:54 +0900 +0900'>March 27, 2025</span></div></header><div class=post-content><p>mnemonic seedを保持していれば、ウォレットの残高をリカバリーできる。これは一見不思議だが、実際には無限に生成可能なアドレス（script pubkey）のうち、使用されたものだけを検出し、UTXOを取得する仕組みがあるためである。どのアドレスが使われたかを追跡できるからこそ、seedを頼りに残高を復元できる。</p><p>しかし、mnemonic seedを持っているのに残高が正しく復旧しないケースも存在する。また、レガシーSegWit（P2SHアドレス・3xxxx）の潜在的な危険性は誤解を生みやすい。これらを整理するために、btc walletの実装（https://github.com/btcsuite/btcwallet）を例にしながら、BIP0044/49/84/86が規定するHDウォレット構造と、ウォレットのリカバリー方法を示す。</p><h2 id=bipの概要と相互関係>BIPの概要と相互関係<a hidden class=anchor aria-hidden=true href=#bipの概要と相互関係>#</a></h2><p>BIP0044、BIP0049、BIP0084、BIP0086はいずれもHDウォレットの「目的（purpose）番号」を定義し、各アドレス形式を区別している。以下、それぞれの要点をまとめる。</p><h3 id=bip44>BIP44<a hidden class=anchor aria-hidden=true href=#bip44>#</a></h3><ul><li><strong>概要</strong>: <code>m/44'/coin_type'/account'/change/address_index</code> の構造を規定する汎用的HDウォレット標準。</li><li><strong>用途</strong>: レガシーP2PKH（1xxxx）アドレスに広く利用されてきた。複数通貨・複数アカウント管理が可能。</li><li><strong>他BIPとの関係</strong>: 新しいアドレス形式に対応するBIP49やBIP84などは、このBIP44をベースにpurpose番号を変えて並立利用できる。</li></ul><h3 id=bip49>BIP49<a hidden class=anchor aria-hidden=true href=#bip49>#</a></h3><ul><li><strong>概要</strong>: <code>m/49'/coin_type'/account'/change/address_index</code> を使い、P2WPKH-in-P2SH（3xxxx）アドレスを定義。</li><li><strong>目的</strong>: 互換性を重視しつつ部分的にSegWitの恩恵（手数料削減など）を得るためのラップドSegWit。</li><li><strong>他BIPとの関係</strong>: レガシー形式（BIP44）を補完し、新しいネイティブSegWit（BIP84）へ移行する中継的役割を果たす。</li></ul><h3 id=bip84>BIP84<a hidden class=anchor aria-hidden=true href=#bip84>#</a></h3><ul><li><strong>概要</strong>: <code>m/84'/coin_type'/account'/change/address_index</code> の構造を使い、ネイティブSegWit（bech32、bc1q&mldr;）アドレスを定義。</li><li><strong>目的</strong>: SegWitの機能をフル活用し、より低い手数料やエラー検知の強化を実現。</li><li><strong>他BIPとの関係</strong>: ラップドSegWit（BIP49）より進んだ純粋なSegWit。Taproot（BIP86）の前段階。</li></ul><h3 id=bip86>BIP86<a hidden class=anchor aria-hidden=true href=#bip86>#</a></h3><ul><li><strong>概要</strong>: <code>m/86'/coin_type'/account'/change/address_index</code> を使い、Taproot（bech32m、bc1p&mldr;）アドレス（単独所有向け）を定義。</li><li><strong>目的</strong>: Schnorr署名やMASTなどTaprootの恩恵（手数料削減・プライバシー向上）を得る。現時点ではシングルキー中心だが、将来的な拡張も想定。</li><li><strong>他BIPとの関係</strong>: ネイティブSegWit（BIP84）より先進的なP2TR形態を扱う。purpose番号86を使い、既存形式と衝突しない。</li></ul><h2 id=bip49がlegacy-segwitと呼ばれる理由>BIP49が「legacy segwit」と呼ばれる理由<a hidden class=anchor aria-hidden=true href=#bip49がlegacy-segwitと呼ばれる理由>#</a></h2><p>BIP49のP2WPKH-in-P2SHアドレス（3xxxx）は見た目が通常のP2SHと同じため、一般に「legacy segwit」とも呼ばれる。P2SHの場合、redeemScriptをユーザ側で保持する必要があるが、BIP49対応ウォレット（例: 多くのハードウェアウォレットなど）を使うなら、redeemScriptを個別にバックアップしなくても済む。</p><h2 id=アドレスインデックスとリカバリー>アドレスインデックスとリカバリー<a hidden class=anchor aria-hidden=true href=#アドレスインデックスとリカバリー>#</a></h2><p>アドレスインデックス（<code>address_index</code>）はウォレットが生成したアドレス数に応じて変化する。復旧時には何番目までアドレスを生成してスキャンするかを決める必要がある。btc walletでは以下のアルゴリズムにより、使用中のアドレスを取りこぼさずに効率的なブロックスキャンを行う。</p><pre class=mermaid>sequenceDiagram
    participant RM as RecoveryManager
    participant RS as RecoveryState
    participant BRS as BranchRecoveryState
    participant BC as Blockchain

    Note over RM: (Resurrectで&lt;br&gt;既存のアドレス・UTXOを復元)

    loop until 全ブロックスキャン完了
        RM-&gt;BC: 次のブロック(群)取得  
        BC--&gt;RM: BlockBatch返却  
        RM-&gt;RS: State取得  
        RM-&gt;&gt;BRS: ExtendHorizon()呼び出し
        alt horizonが不足
            BRS-&gt;&gt;BRS: horizonを拡張&lt;br&gt;(nextUnfound + recoveryWindow)
            note right of BRS: 無効インデックス数も考慮
        end
        RM-&gt;BC: FilterBlocksRequest(生成済みアドレスを照合)
        BC--&gt;RM: FilterBlocksResponse(発見されたaddrのindex)
        RM-&gt;&gt;BRS: ReportFound(index)  
        alt 新しい発見がありnextUnfoundが進む
            BRS-&gt;&gt;BRS: horizon再チェック
        end
    end

    Note over RM: 発見された中で最も高いインデックス +&lt;br&gt;recoveryWindow + 無効インデックス数まで生成し続ける
  </pre><ol><li><strong>Resurrect</strong><br>既知のアドレスやUTXOを <code>RecoveryState</code> に登録し、初期状態をセットする。</li><li><strong>ExtendHorizon</strong><br><code>nextUnfound + recoveryWindow (+ 無効インデックス数)</code> までアドレスを導出・監視対象に加えておき、取りこぼしを防ぐ。</li><li><strong>FilterBlocks</strong><br>実際にブロックをスキャンし、高いインデックスのアドレスが見つかったら <code>ReportFound</code> で更新し、さらに <code>horizon</code> を見直す。</li><li><strong>最終的に</strong><br>最も高いインデックス + recoveryWindow + 無効インデックス数まで検査し、使われている可能性のあるアドレスを漏れなく拾う。</li></ol><hr><p>mnemonic seedさえあれば複数のアドレス形式（P2PKH、P2WPKH-in-P2SH、P2WPKH、Taprootなど）をまとめて手堅くリカバリーできる。目的番号（purpose）を切り替えながら、ウォレットは無数に生成しうるアドレスのうち実使用されたものを判別して残高を復元する。</p><p>よって、各ウォレットで使われるHDウォレット構造（BIP44/49/84/86）を正しく守ることが重要である。これらのBIP（Bitcoin Improvement Proposal）は、アドレスを生成するための派生パスを詳細に規定している。これらの規定に従わずに作成された残高は通常の手順では検出できない。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yusukeshimizu.github.io/blog/>blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>