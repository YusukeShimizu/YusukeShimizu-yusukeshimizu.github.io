<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CTV Template Hash詳細 | blog</title>
<meta name=keywords content><meta name=description content='templateはなにが可変であり、なにが固定なのか、を整理する。
様々な場所に情報があるが、BIPに記されたpython codeを見るのが一番良い。
def ser_compact_size(l):
    r = b""
    if l < 253:
        # Serialize as unsigned char
        r = struct.pack("B", l)
    elif l < 0x10000:
        # Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian)
        r = struct.pack("<BH", 253, l)
    elif l < 0x100000000:
        # Serialize as unsigned char 254 followed by unsigned 4 byte integer (little endian)
        r = struct.pack("<BI", 254, l)
    else:
        # Serialize as unsigned char 255 followed by unsigned 8 byte integer (little endian)
        r = struct.pack("<BQ", 255, l)
    return r

def ser_string(s):
    return ser_compact_size(len(s)) + s

class CTxOut:
    def serialize(self):
        r = b""
        # serialize as signed 8 byte integer (little endian)
        r += struct.pack("<q", self.nValue)
        r += ser_string(self.scriptPubKey)
        return r

def get_default_check_template_precomputed_data(self):
    result = {}
    # If there are no scriptSigs we do not need to precompute a hash
    if any(inp.scriptSig for inp in self.vin):
        result["scriptSigs"] = sha256(b"".join(ser_string(inp.scriptSig) for inp in self.vin))
    # The same value is also pre-computed for and defined in BIP-341 and can be shared.
    # each nSequence is packed as 4 byte unsigned integer (little endian)
    result["sequences"] = sha256(b"".join(struct.pack("<I", inp.nSequence) for inp in self.vin))
    # The same value is also pre-computed for and defined in BIP-341 and can be shared
    # See class CTxOut above for details.
    result["outputs"] = sha256(b"".join(out.serialize() for out in self.vout))
    return result

parameter precomputed must be passed in for DoS resistance
def get_default_check_template_hash(self, nIn, precomputed = None):
    if precomputed == None:
        precomputed = self.get_default_check_template_precomputed_data()
    r = b""
    # Serialize as 4 byte signed integer (little endian)
    r += struct.pack("<i", self.nVersion)
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack("<I", self.nLockTime)
    # we do not include the hash in the case where there is no
    # scriptSigs
    if "scriptSigs" in precomputed:
        r += precomputed["scriptSigs"]
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack("<I", len(self.vin))
    r += precomputed["sequences"]
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack("<I", len(self.vout))
    r += precomputed["outputs"]
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack("<I", nIn)
    return sha256(r)
OP_CHECKTEMPLATEVERIFY（OP_CTV）は「将来使われるトランザクションの形をあらかじめ決めておき、そこから外れる支払いを無効とする」仕組みを提供する。したがって、意図しない送金や改ざんを防ぎながら、VaultやChannel Factoryのような特定用途の“Covenant”機能をシンプルかつ安全に実装できる。'><meta name=author content><link rel=canonical href=https://yusukeshimizu.github.io/blog/posts/CTV-template-hash/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://yusukeshimizu.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yusukeshimizu.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yusukeshimizu.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://yusukeshimizu.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://yusukeshimizu.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yusukeshimizu.github.io/blog/posts/CTV-template-hash/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yusukeshimizu.github.io/blog/posts/CTV-template-hash/"><meta property="og:site_name" content="blog"><meta property="og:title" content="CTV Template Hash詳細"><meta property="og:description" content='templateはなにが可変であり、なにが固定なのか、を整理する。
様々な場所に情報があるが、BIPに記されたpython codeを見るのが一番良い。
def ser_compact_size(l): r = b"" if l < 253: # Serialize as unsigned char r = struct.pack("B", l) elif l < 0x10000: # Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian) r = struct.pack("<BH", 253, l) elif l < 0x100000000: # Serialize as unsigned char 254 followed by unsigned 4 byte integer (little endian) r = struct.pack("<BI", 254, l) else: # Serialize as unsigned char 255 followed by unsigned 8 byte integer (little endian) r = struct.pack("<BQ", 255, l) return r def ser_string(s): return ser_compact_size(len(s)) + s class CTxOut: def serialize(self): r = b"" # serialize as signed 8 byte integer (little endian) r += struct.pack("<q", self.nValue) r += ser_string(self.scriptPubKey) return r def get_default_check_template_precomputed_data(self): result = {} # If there are no scriptSigs we do not need to precompute a hash if any(inp.scriptSig for inp in self.vin): result["scriptSigs"] = sha256(b"".join(ser_string(inp.scriptSig) for inp in self.vin)) # The same value is also pre-computed for and defined in BIP-341 and can be shared. # each nSequence is packed as 4 byte unsigned integer (little endian) result["sequences"] = sha256(b"".join(struct.pack("<I", inp.nSequence) for inp in self.vin)) # The same value is also pre-computed for and defined in BIP-341 and can be shared # See class CTxOut above for details. result["outputs"] = sha256(b"".join(out.serialize() for out in self.vout)) return result parameter precomputed must be passed in for DoS resistance def get_default_check_template_hash(self, nIn, precomputed = None): if precomputed == None: precomputed = self.get_default_check_template_precomputed_data() r = b"" # Serialize as 4 byte signed integer (little endian) r += struct.pack("<i", self.nVersion) # Serialize as 4 byte unsigned integer (little endian) r += struct.pack("<I", self.nLockTime) # we do not include the hash in the case where there is no # scriptSigs if "scriptSigs" in precomputed: r += precomputed["scriptSigs"] # Serialize as 4 byte unsigned integer (little endian) r += struct.pack("<I", len(self.vin)) r += precomputed["sequences"] # Serialize as 4 byte unsigned integer (little endian) r += struct.pack("<I", len(self.vout)) r += precomputed["outputs"] # Serialize as 4 byte unsigned integer (little endian) r += struct.pack("<I", nIn) return sha256(r) OP_CHECKTEMPLATEVERIFY（OP_CTV）は「将来使われるトランザクションの形をあらかじめ決めておき、そこから外れる支払いを無効とする」仕組みを提供する。したがって、意図しない送金や改ざんを防ぎながら、VaultやChannel Factoryのような特定用途の“Covenant”機能をシンプルかつ安全に実装できる。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-24T13:21:13+09:00"><meta property="article:modified_time" content="2025-03-24T13:21:13+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="CTV Template Hash詳細"><meta name=twitter:description content='templateはなにが可変であり、なにが固定なのか、を整理する。
様々な場所に情報があるが、BIPに記されたpython codeを見るのが一番良い。
def ser_compact_size(l):
    r = b""
    if l < 253:
        # Serialize as unsigned char
        r = struct.pack("B", l)
    elif l < 0x10000:
        # Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian)
        r = struct.pack("<BH", 253, l)
    elif l < 0x100000000:
        # Serialize as unsigned char 254 followed by unsigned 4 byte integer (little endian)
        r = struct.pack("<BI", 254, l)
    else:
        # Serialize as unsigned char 255 followed by unsigned 8 byte integer (little endian)
        r = struct.pack("<BQ", 255, l)
    return r

def ser_string(s):
    return ser_compact_size(len(s)) + s

class CTxOut:
    def serialize(self):
        r = b""
        # serialize as signed 8 byte integer (little endian)
        r += struct.pack("<q", self.nValue)
        r += ser_string(self.scriptPubKey)
        return r

def get_default_check_template_precomputed_data(self):
    result = {}
    # If there are no scriptSigs we do not need to precompute a hash
    if any(inp.scriptSig for inp in self.vin):
        result["scriptSigs"] = sha256(b"".join(ser_string(inp.scriptSig) for inp in self.vin))
    # The same value is also pre-computed for and defined in BIP-341 and can be shared.
    # each nSequence is packed as 4 byte unsigned integer (little endian)
    result["sequences"] = sha256(b"".join(struct.pack("<I", inp.nSequence) for inp in self.vin))
    # The same value is also pre-computed for and defined in BIP-341 and can be shared
    # See class CTxOut above for details.
    result["outputs"] = sha256(b"".join(out.serialize() for out in self.vout))
    return result

parameter precomputed must be passed in for DoS resistance
def get_default_check_template_hash(self, nIn, precomputed = None):
    if precomputed == None:
        precomputed = self.get_default_check_template_precomputed_data()
    r = b""
    # Serialize as 4 byte signed integer (little endian)
    r += struct.pack("<i", self.nVersion)
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack("<I", self.nLockTime)
    # we do not include the hash in the case where there is no
    # scriptSigs
    if "scriptSigs" in precomputed:
        r += precomputed["scriptSigs"]
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack("<I", len(self.vin))
    r += precomputed["sequences"]
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack("<I", len(self.vout))
    r += precomputed["outputs"]
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack("<I", nIn)
    return sha256(r)
OP_CHECKTEMPLATEVERIFY（OP_CTV）は「将来使われるトランザクションの形をあらかじめ決めておき、そこから外れる支払いを無効とする」仕組みを提供する。したがって、意図しない送金や改ざんを防ぎながら、VaultやChannel Factoryのような特定用途の“Covenant”機能をシンプルかつ安全に実装できる。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yusukeshimizu.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"CTV Template Hash詳細","item":"https://yusukeshimizu.github.io/blog/posts/CTV-template-hash/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CTV Template Hash詳細","name":"CTV Template Hash詳細","description":"templateはなにが可変であり、なにが固定なのか、を整理する。\n様々な場所に情報があるが、BIPに記されたpython codeを見るのが一番良い。\ndef ser_compact_size(l): r = b\u0026#34;\u0026#34; if l \u0026lt; 253: # Serialize as unsigned char r = struct.pack(\u0026#34;B\u0026#34;, l) elif l \u0026lt; 0x10000: # Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian) r = struct.pack(\u0026#34;\u0026lt;BH\u0026#34;, 253, l) elif l \u0026lt; 0x100000000: # Serialize as unsigned char 254 followed by unsigned 4 byte integer (little endian) r = struct.pack(\u0026#34;\u0026lt;BI\u0026#34;, 254, l) else: # Serialize as unsigned char 255 followed by unsigned 8 byte integer (little endian) r = struct.pack(\u0026#34;\u0026lt;BQ\u0026#34;, 255, l) return r def ser_string(s): return ser_compact_size(len(s)) + s class CTxOut: def serialize(self): r = b\u0026#34;\u0026#34; # serialize as signed 8 byte integer (little endian) r += struct.pack(\u0026#34;\u0026lt;q\u0026#34;, self.nValue) r += ser_string(self.scriptPubKey) return r def get_default_check_template_precomputed_data(self): result = {} # If there are no scriptSigs we do not need to precompute a hash if any(inp.scriptSig for inp in self.vin): result[\u0026#34;scriptSigs\u0026#34;] = sha256(b\u0026#34;\u0026#34;.join(ser_string(inp.scriptSig) for inp in self.vin)) # The same value is also pre-computed for and defined in BIP-341 and can be shared. # each nSequence is packed as 4 byte unsigned integer (little endian) result[\u0026#34;sequences\u0026#34;] = sha256(b\u0026#34;\u0026#34;.join(struct.pack(\u0026#34;\u0026lt;I\u0026#34;, inp.nSequence) for inp in self.vin)) # The same value is also pre-computed for and defined in BIP-341 and can be shared # See class CTxOut above for details. result[\u0026#34;outputs\u0026#34;] = sha256(b\u0026#34;\u0026#34;.join(out.serialize() for out in self.vout)) return result parameter precomputed must be passed in for DoS resistance def get_default_check_template_hash(self, nIn, precomputed = None): if precomputed == None: precomputed = self.get_default_check_template_precomputed_data() r = b\u0026#34;\u0026#34; # Serialize as 4 byte signed integer (little endian) r += struct.pack(\u0026#34;\u0026lt;i\u0026#34;, self.nVersion) # Serialize as 4 byte unsigned integer (little endian) r += struct.pack(\u0026#34;\u0026lt;I\u0026#34;, self.nLockTime) # we do not include the hash in the case where there is no # scriptSigs if \u0026#34;scriptSigs\u0026#34; in precomputed: r += precomputed[\u0026#34;scriptSigs\u0026#34;] # Serialize as 4 byte unsigned integer (little endian) r += struct.pack(\u0026#34;\u0026lt;I\u0026#34;, len(self.vin)) r += precomputed[\u0026#34;sequences\u0026#34;] # Serialize as 4 byte unsigned integer (little endian) r += struct.pack(\u0026#34;\u0026lt;I\u0026#34;, len(self.vout)) r += precomputed[\u0026#34;outputs\u0026#34;] # Serialize as 4 byte unsigned integer (little endian) r += struct.pack(\u0026#34;\u0026lt;I\u0026#34;, nIn) return sha256(r) OP_CHECKTEMPLATEVERIFY（OP_CTV）は「将来使われるトランザクションの形をあらかじめ決めておき、そこから外れる支払いを無効とする」仕組みを提供する。したがって、意図しない送金や改ざんを防ぎながら、VaultやChannel Factoryのような特定用途の“Covenant”機能をシンプルかつ安全に実装できる。\n","keywords":[],"articleBody":"templateはなにが可変であり、なにが固定なのか、を整理する。\n様々な場所に情報があるが、BIPに記されたpython codeを見るのが一番良い。\ndef ser_compact_size(l): r = b\"\" if l \u003c 253: # Serialize as unsigned char r = struct.pack(\"B\", l) elif l \u003c 0x10000: # Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian) r = struct.pack(\"","wordCount":"385","inLanguage":"en","datePublished":"2025-03-24T13:21:13+09:00","dateModified":"2025-03-24T13:21:13+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://yusukeshimizu.github.io/blog/posts/CTV-template-hash/"},"publisher":{"@type":"Organization","name":"blog","logo":{"@type":"ImageObject","url":"https://yusukeshimizu.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yusukeshimizu.github.io/blog/ accesskey=h title="blog (Alt + H)">blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CTV Template Hash詳細</h1><div class=post-meta><span title='2025-03-24 13:21:13 +0900 +0900'>March 24, 2025</span></div></header><div class=post-content><p>templateはなにが可変であり、なにが固定なのか、を整理する。<br>様々な場所に情報があるが、BIPに記されたpython codeを見るのが一番良い。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ser_compact_size</span>(l):
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> l <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>253</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Serialize as unsigned char</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;B&#34;</span>, l)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> l <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x10000</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian)</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;BH&#34;</span>, <span style=color:#ae81ff>253</span>, l)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> l <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x100000000</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Serialize as unsigned char 254 followed by unsigned 4 byte integer (little endian)</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;BI&#34;</span>, <span style=color:#ae81ff>254</span>, l)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Serialize as unsigned char 255 followed by unsigned 8 byte integer (little endian)</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;BQ&#34;</span>, <span style=color:#ae81ff>255</span>, l)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> r
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ser_string</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ser_compact_size(len(s)) <span style=color:#f92672>+</span> s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CTxOut</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>serialize</span>(self):
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># serialize as signed 8 byte integer (little endian)</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;q&#34;</span>, self<span style=color:#f92672>.</span>nValue)
</span></span><span style=display:flex><span>        r <span style=color:#f92672>+=</span> ser_string(self<span style=color:#f92672>.</span>scriptPubKey)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> r
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_default_check_template_precomputed_data</span>(self):
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#75715e># If there are no scriptSigs we do not need to precompute a hash</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> any(inp<span style=color:#f92672>.</span>scriptSig <span style=color:#66d9ef>for</span> inp <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>vin):
</span></span><span style=display:flex><span>        result[<span style=color:#e6db74>&#34;scriptSigs&#34;</span>] <span style=color:#f92672>=</span> sha256(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(ser_string(inp<span style=color:#f92672>.</span>scriptSig) <span style=color:#66d9ef>for</span> inp <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>vin))
</span></span><span style=display:flex><span>    <span style=color:#75715e># The same value is also pre-computed for and defined in BIP-341 and can be shared.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># each nSequence is packed as 4 byte unsigned integer (little endian)</span>
</span></span><span style=display:flex><span>    result[<span style=color:#e6db74>&#34;sequences&#34;</span>] <span style=color:#f92672>=</span> sha256(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, inp<span style=color:#f92672>.</span>nSequence) <span style=color:#66d9ef>for</span> inp <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>vin))
</span></span><span style=display:flex><span>    <span style=color:#75715e># The same value is also pre-computed for and defined in BIP-341 and can be shared</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># See class CTxOut above for details.</span>
</span></span><span style=display:flex><span>    result[<span style=color:#e6db74>&#34;outputs&#34;</span>] <span style=color:#f92672>=</span> sha256(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(out<span style=color:#f92672>.</span>serialize() <span style=color:#66d9ef>for</span> out <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>vout))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>parameter precomputed must be passed <span style=color:#f92672>in</span> <span style=color:#66d9ef>for</span> DoS resistance
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_default_check_template_hash</span>(self, nIn, precomputed <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> precomputed <span style=color:#f92672>==</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        precomputed <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>get_default_check_template_precomputed_data()
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Serialize as 4 byte signed integer (little endian)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;i&#34;</span>, self<span style=color:#f92672>.</span>nVersion)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Serialize as 4 byte unsigned integer (little endian)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, self<span style=color:#f92672>.</span>nLockTime)
</span></span><span style=display:flex><span>    <span style=color:#75715e># we do not include the hash in the case where there is no</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># scriptSigs</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;scriptSigs&#34;</span> <span style=color:#f92672>in</span> precomputed:
</span></span><span style=display:flex><span>        r <span style=color:#f92672>+=</span> precomputed[<span style=color:#e6db74>&#34;scriptSigs&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Serialize as 4 byte unsigned integer (little endian)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, len(self<span style=color:#f92672>.</span>vin))
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> precomputed[<span style=color:#e6db74>&#34;sequences&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Serialize as 4 byte unsigned integer (little endian)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, len(self<span style=color:#f92672>.</span>vout))
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> precomputed[<span style=color:#e6db74>&#34;outputs&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Serialize as 4 byte unsigned integer (little endian)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, nIn)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sha256(r)
</span></span></code></pre></div><p>OP_CHECKTEMPLATEVERIFY（OP_CTV）は「将来使われるトランザクションの形をあらかじめ決めておき、そこから外れる支払いを無効とする」仕組みを提供する。したがって、意図しない送金や改ざんを防ぎながら、VaultやChannel Factoryのような特定用途の“Covenant”機能をシンプルかつ安全に実装できる。</p><hr><h2 id=1-op_ctvの基本的な動作>1. OP_CTVの基本的な動作<a hidden class=anchor aria-hidden=true href=#1-op_ctvの基本的な動作>#</a></h2><p>OP_CTVは「スクリプト内でコミットしたテンプレート（トランザクションのひな型）と、実際のトランザクションのハッシュが一致するか」を検証する。テンプレートと一致しなければコインは使えない。これにより、次回消費される形式を厳密に制約し、想定外のパラメータを排除できる。</p><ol><li>テンプレートには、送金先アドレスや金額（nValue）、トランザクションバージョン、LockTime、入力数などを含める。</li><li>テンプレートと異なる要素を含んだトランザクションは無効となる。</li></ol><hr><h2 id=2-コード例が示すテンプレートハッシュ計算>2. コード例が示すテンプレートハッシュ計算<a hidden class=anchor aria-hidden=true href=#2-コード例が示すテンプレートハッシュ計算>#</a></h2><p><code>get_default_check_template_precomputed_data()</code>と<code>get_default_check_template_hash()</code>が含まれる。これらはトランザクションを構成する主要部分をハッシュ化した“テンプレートハッシュ”を生成する。</p><ol><li><p><code>get_default_check_template_precomputed_data()</code><br>各入力のscriptSigやsequence、出力一覧（vout）のserializedデータなどを個別にSHA-256でハッシュ化し、その結果をまとめて返す。</p></li><li><p><code>get_default_check_template_hash()</code><br>バージョンやLockTime、入力数、出力数などの情報と先ほどの部分的ハッシュを組み合わせ、最終的なテンプレートハッシュを生成する。OP_CTVはスクリプト実行時、このテンプレートハッシュとトランザクションの実体が一致するかをチェックする。</p></li></ol><hr><h2 id=3-op_ctvの柔軟性と制約>3. OP_CTVの柔軟性と制約<a hidden class=anchor aria-hidden=true href=#3-op_ctvの柔軟性と制約>#</a></h2><h3 id=31-柔軟性>3.1 柔軟性<a hidden class=anchor aria-hidden=true href=#31-柔軟性>#</a></h3><ul><li><strong>出力（vout）の完全固定</strong><br>送金先アドレスや金額が厳密に定義され、改ざんの余地をなくす。</li><li><strong>入力数やLockTimeなど特定パラメータも固定</strong><br>コミットした要素が変わるとハッシュが変化し、無効になる。将来のマルチシグや複数人の共同トランザクションでも、明確なテンプレートを用意すれば対応できる。</li></ul><h3 id=32-できること>3.2 できること<a hidden class=anchor aria-hidden=true href=#32-できること>#</a></h3><ul><li><strong>VaultなどのCovenant機能</strong><br>コインをロックして将来の引き出し条件を限定するシナリオ（例: Vault）をシンプルに実装できる。</li><li><strong>複数参加者のチャネル構成</strong><br>将来の各出力パターンをテンプレート化し、決まったルール内でのみ協調取引できる。</li><li><strong>CPU負荷削減</strong><br>データの事前ハッシュ（プリコンピュート）によって、無駄な計算量を減らせる。</li></ul><h3 id=33-制約>3.3 制約<a hidden class=anchor aria-hidden=true href=#33-制約>#</a></h3><ul><li><strong>複雑な条件分岐の難しさ</strong><br>OP_CTVは「テンプレート一致のチェック」のみを行う。分岐や動的ロジックを増やすには、複数ハッシュパスを用意するなどの工夫が必要である。</li><li><strong>テンプレート外の自由度の低下</strong><br>コミットされた内容以外での送金やロジックは通用しない。多様な将来計画を考慮するなら、複数のテンプレートを準備すべきである。</li><li><strong>管理と承認フローの煩雑化</strong><br>参加者が多いマルチパーティーでは、全員にとって想定されるパターンを事前にテンプレート化する必要があり、スクリプトサイズも増え得る。</li></ul><hr><h2 id=4-まとめ>4. まとめ<a hidden class=anchor aria-hidden=true href=#4-まとめ>#</a></h2><p>OP_CTVは、将来のトランザクションをテンプレートという形で厳密に固定し、セキュリティや改ざん防止を大きく強化する。一方で、複雑なロジックや高度な条件分岐には向かない。したがって、Vaultのような限定された用途には最適であるが、汎用的な拡張には別のアプローチも検討すべきである。提示コードが示すように、出力や各種フィールドをハッシュ化して照合する一連の手順によって、シンプルかつ強力なCovenant機能を実現できる。</p><p>OP_CHECKTEMPLATEVERIFY（以下、OP_CTV）は「<strong>あらかじめ定義した特定のトランザクション形式（テンプレート）にしか支払いを許可しない</strong>」という性質を持つ新しいOPコード案（BIP-119）です。ここでは提示されたコード片（<code>get_default_check_template_precomputed_data</code>や<code>get_default_check_template_hash</code> など）を例に、OP_CTV（BIP-119）の仕組みと「どこまで柔軟性があるか」について解説します。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yusukeshimizu.github.io/blog/>blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>