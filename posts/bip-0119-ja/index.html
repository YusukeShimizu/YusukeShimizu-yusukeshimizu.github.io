<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>bip-0119 | blog</title>
<meta name=keywords content><meta name=description content="BIP 119の日本語訳をおいておく。
この記事は、llmにより翻訳されたものであり、内容に誤りがある可能性はある。
BIP 119は、新しいオペコード OP_CHECKTEMPLATEVERIFY を有効化することを提案しており、このブログを書いた段階で、有力な選択肢となっている。
Developer Consensus May Be Converging on a Bitcoin Soft Fork Proposal: Blockspace
なお、この記事は、commit hash88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f 時点のものとなっている。

Abstract
Summary
Motivation
Detailed Specification
デプロイ
参考実装
根拠

The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack

Committing to the version and locktime
Committing to the ScriptSigs Hash
インプット数へのコミット
シーケンスハッシュへのコミット
アウトプット数へのコミット
アウトプットハッシュへのコミット
現在のインプットのインデックスへのコミット
Committing to Values by Hash
Using SHA256
Using Non-Tagged Hashes
The Ordering of Fields


設計上のトレードオフとリスク

Denial of Service and Validation Costs
永久に使用できない出力
転送アドレス
NOP-Default and Recommended Standardness Rules
機能の冗長性
将来的なアップグレード

CHECKTEMPLATEVERIFY バージョン
OP_CHECKSIGFROMSTACKVERIFY
OP_AMOUNTVERIFY
OP_CAT/OP_SHA256STREAM






Backwards Compatibility
スクリプト互換性
References

類似した代替案について


著作権


BIP: 119
Layer: Consensus (soft fork)
Title: CHECKTEMPLATEVERIFY
Author: Jeremy Rubin j@rubin.io
Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0119
Status: Draft
Type: Standards Track
Created: 2020-01-06
License: BSD-3-Clause"><meta name=author content><link rel=canonical href=https://yusukeshimizu.github.io/blog/posts/bip-0119-ja/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://yusukeshimizu.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yusukeshimizu.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yusukeshimizu.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://yusukeshimizu.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://yusukeshimizu.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yusukeshimizu.github.io/blog/posts/bip-0119-ja/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yusukeshimizu.github.io/blog/posts/bip-0119-ja/"><meta property="og:site_name" content="blog"><meta property="og:title" content="bip-0119"><meta property="og:description" content="BIP 119の日本語訳をおいておく。
この記事は、llmにより翻訳されたものであり、内容に誤りがある可能性はある。
BIP 119は、新しいオペコード OP_CHECKTEMPLATEVERIFY を有効化することを提案しており、このブログを書いた段階で、有力な選択肢となっている。
Developer Consensus May Be Converging on a Bitcoin Soft Fork Proposal: Blockspace
なお、この記事は、commit hash88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f 時点のものとなっている。
Abstract Summary Motivation Detailed Specification デプロイ 参考実装 根拠 The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack Committing to the version and locktime Committing to the ScriptSigs Hash インプット数へのコミット シーケンスハッシュへのコミット アウトプット数へのコミット アウトプットハッシュへのコミット 現在のインプットのインデックスへのコミット Committing to Values by Hash Using SHA256 Using Non-Tagged Hashes The Ordering of Fields 設計上のトレードオフとリスク Denial of Service and Validation Costs 永久に使用できない出力 転送アドレス NOP-Default and Recommended Standardness Rules 機能の冗長性 将来的なアップグレード CHECKTEMPLATEVERIFY バージョン OP_CHECKSIGFROMSTACKVERIFY OP_AMOUNTVERIFY OP_CAT/OP_SHA256STREAM Backwards Compatibility スクリプト互換性 References 類似した代替案について 著作権 BIP: 119
Layer: Consensus (soft fork)
Title: CHECKTEMPLATEVERIFY
Author: Jeremy Rubin j@rubin.io
Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0119
Status: Draft
Type: Standards Track
Created: 2020-01-06
License: BSD-3-Clause"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-22T08:56:49+09:00"><meta property="article:modified_time" content="2025-03-22T08:56:49+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="bip-0119"><meta name=twitter:description content="BIP 119の日本語訳をおいておく。
この記事は、llmにより翻訳されたものであり、内容に誤りがある可能性はある。
BIP 119は、新しいオペコード OP_CHECKTEMPLATEVERIFY を有効化することを提案しており、このブログを書いた段階で、有力な選択肢となっている。
Developer Consensus May Be Converging on a Bitcoin Soft Fork Proposal: Blockspace
なお、この記事は、commit hash88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f 時点のものとなっている。

Abstract
Summary
Motivation
Detailed Specification
デプロイ
参考実装
根拠

The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack

Committing to the version and locktime
Committing to the ScriptSigs Hash
インプット数へのコミット
シーケンスハッシュへのコミット
アウトプット数へのコミット
アウトプットハッシュへのコミット
現在のインプットのインデックスへのコミット
Committing to Values by Hash
Using SHA256
Using Non-Tagged Hashes
The Ordering of Fields


設計上のトレードオフとリスク

Denial of Service and Validation Costs
永久に使用できない出力
転送アドレス
NOP-Default and Recommended Standardness Rules
機能の冗長性
将来的なアップグレード

CHECKTEMPLATEVERIFY バージョン
OP_CHECKSIGFROMSTACKVERIFY
OP_AMOUNTVERIFY
OP_CAT/OP_SHA256STREAM






Backwards Compatibility
スクリプト互換性
References

類似した代替案について


著作権


BIP: 119
Layer: Consensus (soft fork)
Title: CHECKTEMPLATEVERIFY
Author: Jeremy Rubin j@rubin.io
Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0119
Status: Draft
Type: Standards Track
Created: 2020-01-06
License: BSD-3-Clause"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yusukeshimizu.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"bip-0119","item":"https://yusukeshimizu.github.io/blog/posts/bip-0119-ja/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"bip-0119","name":"bip-0119","description":"BIP 119の日本語訳をおいておく。\nこの記事は、llmにより翻訳されたものであり、内容に誤りがある可能性はある。\nBIP 119は、新しいオペコード OP_CHECKTEMPLATEVERIFY を有効化することを提案しており、このブログを書いた段階で、有力な選択肢となっている。\nDeveloper Consensus May Be Converging on a Bitcoin Soft Fork Proposal: Blockspace\nなお、この記事は、commit hash88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f 時点のものとなっている。\nAbstract Summary Motivation Detailed Specification デプロイ 参考実装 根拠 The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack Committing to the version and locktime Committing to the ScriptSigs Hash インプット数へのコミット シーケンスハッシュへのコミット アウトプット数へのコミット アウトプットハッシュへのコミット 現在のインプットのインデックスへのコミット Committing to Values by Hash Using SHA256 Using Non-Tagged Hashes The Ordering of Fields 設計上のトレードオフとリスク Denial of Service and Validation Costs 永久に使用できない出力 転送アドレス NOP-Default and Recommended Standardness Rules 機能の冗長性 将来的なアップグレード CHECKTEMPLATEVERIFY バージョン OP_CHECKSIGFROMSTACKVERIFY OP_AMOUNTVERIFY OP_CAT/OP_SHA256STREAM Backwards Compatibility スクリプト互換性 References 類似した代替案について 著作権 BIP: 119\nLayer: Consensus (soft fork)\nTitle: CHECKTEMPLATEVERIFY\nAuthor: Jeremy Rubin j@rubin.io\nComments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0119\nStatus: Draft\nType: Standards Track\nCreated: 2020-01-06\nLicense: BSD-3-Clause\n","keywords":[],"articleBody":"BIP 119の日本語訳をおいておく。\nこの記事は、llmにより翻訳されたものであり、内容に誤りがある可能性はある。\nBIP 119は、新しいオペコード OP_CHECKTEMPLATEVERIFY を有効化することを提案しており、このブログを書いた段階で、有力な選択肢となっている。\nDeveloper Consensus May Be Converging on a Bitcoin Soft Fork Proposal: Blockspace\nなお、この記事は、commit hash88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f 時点のものとなっている。\nAbstract Summary Motivation Detailed Specification デプロイ 参考実装 根拠 The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack Committing to the version and locktime Committing to the ScriptSigs Hash インプット数へのコミット シーケンスハッシュへのコミット アウトプット数へのコミット アウトプットハッシュへのコミット 現在のインプットのインデックスへのコミット Committing to Values by Hash Using SHA256 Using Non-Tagged Hashes The Ordering of Fields 設計上のトレードオフとリスク Denial of Service and Validation Costs 永久に使用できない出力 転送アドレス NOP-Default and Recommended Standardness Rules 機能の冗長性 将来的なアップグレード CHECKTEMPLATEVERIFY バージョン OP_CHECKSIGFROMSTACKVERIFY OP_AMOUNTVERIFY OP_CAT/OP_SHA256STREAM Backwards Compatibility スクリプト互換性 References 類似した代替案について 著作権 BIP: 119\nLayer: Consensus (soft fork)\nTitle: CHECKTEMPLATEVERIFY\nAuthor: Jeremy Rubin j@rubin.io\nComments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0119\nStatus: Draft\nType: Standards Track\nCreated: 2020-01-06\nLicense: BSD-3-Clause\nAbstract この BIP は、新しいオペコード OP_CHECKTEMPLATEVERIFY を有効化することを提案しており、OP_NOP4 のセマンティクスを変更する形で適用されます。\nSummary OP_CHECKTEMPLATEVERIFY は、オペコード OP_NOP4 (0xb3) をソフトフォークによるアップグレードとして使用します。\nOP_CHECKTEMPLATEVERIFY は次のような処理を行います：\nスタック上に少なくとも 1 つの要素がある。ない場合は失敗。 スタック上の要素が 32 バイト長である。そうでなければ NOP。 現在の入力インデックスにあるトランザクションの DefaultCheckTemplateVerifyHash がスタック上の要素と等しい。そうでなければ失敗。 DefaultCheckTemplateVerifyHash はシリアライズされたバージョン、locktime、scriptSigs ハッシュ (もし非 null の scriptSigs がある場合)、インプット数、sequences ハッシュ、アウトプット数、アウトプット ハッシュ、そして現在実行中の入力インデックスにコミットします。\n推奨される標準性ルールとしてさらに：\n32 バイト以外は SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS として拒否。 Motivation この BIP は、トランザクションテンプレートを導入します。これは、ハッシュ化されたトランザクション仕様に対してパターンマッチすることで簡易的な支出制限を実現するものです。OP_CHECKTEMPLATEVERIFY は、アプリケーションで事前署名を使用する際に内在する信頼・対話性・ストレージ要件を大きく削減します。アプリケーションの詳細についてはリファレンスを参照してください。\nDetailed Specification 以下のコードは、CHECKTEMPLATEVERIFY を検証するメインロジックを示したもので、Python 風の擬似コードで記述しています。OP_CHECKTEMPLATEVERIFY の仕様としての正準的な定義は、Bitcoin Core の文脈で C++ で実装されたリファレンス実装を参照してください。\nThe execution of the opcode is as follows:\ndef execute_bip_119(self): # Before soft-fork activation / failed activation # continue to treat as NOP4 if not self.flags.script_verify_default_check_template_verify_hash: # Potentially set for node-local policy to discourage premature use if self.flags.script_verify_discourage_upgradable_nops: return self.errors_with(errors.script_err_discourage_upgradable_nops) return self.return_as_nop() # CTV always requires at least one stack argument if len(self.stack) \u003c 1: return self.errors_with(errors.script_err_invalid_stack_operation) # CTV only verifies the hash against a 32 byte argument if len(self.stack[-1]) == 32: # Ensure the precomputed data required for anti-DoS is available, # or cache it on first use if self.context.precomputed_ctv_data == None: self.context.precomputed_ctv_data = self.context.tx.get_default_check_template_precomputed_data() # If the hashes do not match, return error if stack[-1] != self.context.tx.get_default_check_template_hash(self.context.nIn, self.context.precomputed_ctv_data): return self.errors_with(errors.script_err_template_mismatch) return self.return_as_nop() # future upgrade can add semantics for this opcode with different length args # so discourage use when applicable if self.flags.script_verify_discourage_upgradable_nops: return self.errors_with(errors.script_err_discourage_upgradable_nops) else: return self.return_as_nop() このハッシュの計算は、以下に示すように実装できます (ここで self はトランザクション型を指します)。どのような検証コンテキストでも、事前計算されたデータが初期化されていないとサービス妨害攻撃を招く可能性があるため注意が必要です。任意の実装は、二次元的なハッシュ計算による DoS を回避するために、これらのハッシュ計算部分をキャッシュしなければなりません。scriptsig、sequence、アウトプットなど可変長のすべての計算は事前計算を行う必要があります。詳細は「Denial of Service and Validation Costs」を参照してください。これは性能最適化ではありません。\ndef ser_compact_size(l): r = b\"\" if l \u003c 253: # Serialize as unsigned char r = struct.pack(\"B\", l) elif l \u003c 0x10000: # Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian) r = struct.pack(\"","wordCount":"1668","inLanguage":"en","datePublished":"2025-03-22T08:56:49+09:00","dateModified":"2025-03-22T08:56:49+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://yusukeshimizu.github.io/blog/posts/bip-0119-ja/"},"publisher":{"@type":"Organization","name":"blog","logo":{"@type":"ImageObject","url":"https://yusukeshimizu.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yusukeshimizu.github.io/blog/ accesskey=h title="blog (Alt + H)">blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">bip-0119</h1><div class=post-meta><span title='2025-03-22 08:56:49 +0900 +0900'>March 22, 2025</span></div></header><div class=post-content><p>BIP 119の日本語訳をおいておく。</p><p>この記事は、llmにより翻訳されたものであり、内容に誤りがある可能性はある。<br>BIP 119は、新しいオペコード OP_CHECKTEMPLATEVERIFY を有効化することを提案しており、このブログを書いた段階で、有力な選択肢となっている。<br><a href=https://www.coindesk.com/tech/2025/03/17/developer-consensus-may-be-converging-on-a-bitcoin-soft-fork-proposal-blockspace>Developer Consensus May Be Converging on a Bitcoin Soft Fork Proposal: Blockspace</a></p><p>なお、この記事は、commit hash<a href=https://github.com/bitcoin/bips/blob/88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f/bip-0119.mediawiki>88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f</a> 時点のものとなっている。</p><ul><li><a href=#abstract>Abstract</a></li><li><a href=#summary>Summary</a></li><li><a href=#motivation>Motivation</a></li><li><a href=#detailed-specification>Detailed Specification</a></li><li><a href=#%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4>デプロイ</a></li><li><a href=#%E5%8F%82%E8%80%83%E5%AE%9F%E8%A3%85>参考実装</a></li><li><a href=#%E6%A0%B9%E6%8B%A0>根拠</a><ul><li><a href=#the-defaultchecktemplateverifyhash-of-the-transaction-at-the-current-input-index-matches-the-top-of-the-stack>The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack</a><ul><li><a href=#committing-to-the-version-and-locktime>Committing to the version and locktime</a></li><li><a href=#committing-to-the-scriptsigs-hash>Committing to the ScriptSigs Hash</a></li><li><a href=#%E3%82%A4%E3%83%B3%E3%83%97%E3%83%83%E3%83%88%E6%95%B0%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88>インプット数へのコミット</a></li><li><a href=#%E3%82%B7%E3%83%BC%E3%82%B1%E3%83%B3%E3%82%B9%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88>シーケンスハッシュへのコミット</a></li><li><a href=#%E3%82%A2%E3%82%A6%E3%83%88%E3%83%97%E3%83%83%E3%83%88%E6%95%B0%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88>アウトプット数へのコミット</a></li><li><a href=#%E3%82%A2%E3%82%A6%E3%83%88%E3%83%97%E3%83%83%E3%83%88%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88>アウトプットハッシュへのコミット</a></li><li><a href=#%E7%8F%BE%E5%9C%A8%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%97%E3%83%83%E3%83%88%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88>現在のインプットのインデックスへのコミット</a></li><li><a href=#committing-to-values-by-hash>Committing to Values by Hash</a></li><li><a href=#using-sha256>Using SHA256</a></li><li><a href=#using-non-tagged-hashes>Using Non-Tagged Hashes</a></li><li><a href=#the-ordering-of-fields>The Ordering of Fields</a></li></ul></li><li><a href=#%E8%A8%AD%E8%A8%88%E4%B8%8A%E3%81%AE%E3%83%88%E3%83%AC%E3%83%BC%E3%83%89%E3%82%AA%E3%83%95%E3%81%A8%E3%83%AA%E3%82%B9%E3%82%AF>設計上のトレードオフとリスク</a><ul><li><a href=#denial-of-service-and-validation-costs>Denial of Service and Validation Costs</a></li><li><a href=#%E6%B0%B8%E4%B9%85%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E5%87%BA%E5%8A%9B>永久に使用できない出力</a></li><li><a href=#%E8%BB%A2%E9%80%81%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9>転送アドレス</a></li><li><a href=#nop-default-and-recommended-standardness-rules>NOP-Default and Recommended Standardness Rules</a></li><li><a href=#%E6%A9%9F%E8%83%BD%E3%81%AE%E5%86%97%E9%95%B7%E6%80%A7>機能の冗長性</a></li><li><a href=#%E5%B0%86%E6%9D%A5%E7%9A%84%E3%81%AA%E3%82%A2%E3%83%83%E3%83%97%E3%82%B0%E3%83%AC%E3%83%BC%E3%83%89>将来的なアップグレード</a><ul><li><a href=#checktemplateverify-%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3>CHECKTEMPLATEVERIFY バージョン</a></li><li><a href=#op_checksigfromstackverify>OP_CHECKSIGFROMSTACKVERIFY</a></li><li><a href=#op_amountverify>OP_AMOUNTVERIFY</a></li><li><a href=#op_catop_sha256stream>OP_CAT/OP_SHA256STREAM</a></li></ul></li></ul></li></ul></li><li><a href=#backwards-compatibility>Backwards Compatibility</a></li><li><a href=#%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E4%BA%92%E6%8F%9B%E6%80%A7>スクリプト互換性</a></li><li><a href=#references>References</a><ul><li><a href=#%E9%A1%9E%E4%BC%BC%E3%81%97%E3%81%9F%E4%BB%A3%E6%9B%BF%E6%A1%88%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6>類似した代替案について</a></li></ul></li><li><a href=#%E8%91%97%E4%BD%9C%E6%A8%A9>著作権</a></li></ul><hr><p>BIP: 119<br>Layer: Consensus (soft fork)<br>Title: CHECKTEMPLATEVERIFY<br>Author: Jeremy Rubin <a href=mailto:j@rubin.io>j@rubin.io</a><br>Comments-URI: <a href=https://github.com/bitcoin/bips/wiki/Comments:BIP-0119>https://github.com/bitcoin/bips/wiki/Comments:BIP-0119</a><br>Status: Draft<br>Type: Standards Track<br>Created: 2020-01-06<br>License: BSD-3-Clause</p><h2 id=abstract>Abstract<a hidden class=anchor aria-hidden=true href=#abstract>#</a></h2><p>この BIP は、新しいオペコード OP_CHECKTEMPLATEVERIFY を有効化することを提案しており、OP_NOP4 のセマンティクスを変更する形で適用されます。</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>OP_CHECKTEMPLATEVERIFY は、オペコード OP_NOP4 (0xb3) をソフトフォークによるアップグレードとして使用します。</p><p>OP_CHECKTEMPLATEVERIFY は次のような処理を行います：</p><ul><li>スタック上に少なくとも 1 つの要素がある。ない場合は失敗。</li><li>スタック上の要素が 32 バイト長である。そうでなければ NOP。</li><li>現在の入力インデックスにあるトランザクションの DefaultCheckTemplateVerifyHash がスタック上の要素と等しい。そうでなければ失敗。</li></ul><p>DefaultCheckTemplateVerifyHash はシリアライズされたバージョン、locktime、scriptSigs ハッシュ (もし非 null の scriptSigs がある場合)、インプット数、sequences ハッシュ、アウトプット数、アウトプット ハッシュ、そして現在実行中の入力インデックスにコミットします。</p><p>推奨される標準性ルールとしてさらに：</p><ul><li>32 バイト以外は SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS として拒否。</li></ul><h2 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h2><p>この BIP は、トランザクションテンプレートを導入します。これは、ハッシュ化されたトランザクション仕様に対してパターンマッチすることで簡易的な支出制限を実現するものです。OP_CHECKTEMPLATEVERIFY は、アプリケーションで事前署名を使用する際に内在する信頼・対話性・ストレージ要件を大きく削減します。アプリケーションの詳細についてはリファレンスを参照してください。</p><h2 id=detailed-specification>Detailed Specification<a hidden class=anchor aria-hidden=true href=#detailed-specification>#</a></h2><p>以下のコードは、CHECKTEMPLATEVERIFY を検証するメインロジックを示したもので、Python 風の擬似コードで記述しています。OP_CHECKTEMPLATEVERIFY の仕様としての正準的な定義は、Bitcoin Core の文脈で C++ で実装されたリファレンス実装を参照してください。</p><p>The execution of the opcode is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_bip_119</span>(self):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Before soft-fork activation / failed activation</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># continue to treat as NOP4</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>flags<span style=color:#f92672>.</span>script_verify_default_check_template_verify_hash:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Potentially set for node-local policy to discourage premature use</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>flags<span style=color:#f92672>.</span>script_verify_discourage_upgradable_nops:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>errors_with(errors<span style=color:#f92672>.</span>script_err_discourage_upgradable_nops)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>return_as_nop()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># CTV always requires at least one stack argument</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(self<span style=color:#f92672>.</span>stack) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>errors_with(errors<span style=color:#f92672>.</span>script_err_invalid_stack_operation)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># CTV only verifies the hash against a 32 byte argument</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(self<span style=color:#f92672>.</span>stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) <span style=color:#f92672>==</span> <span style=color:#ae81ff>32</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Ensure the precomputed data required for anti-DoS is available,</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># or cache it on first use</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>context<span style=color:#f92672>.</span>precomputed_ctv_data <span style=color:#f92672>==</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>context<span style=color:#f92672>.</span>precomputed_ctv_data <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>context<span style=color:#f92672>.</span>tx<span style=color:#f92672>.</span>get_default_check_template_precomputed_data()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># If the hashes do not match, return error</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>!=</span> self<span style=color:#f92672>.</span>context<span style=color:#f92672>.</span>tx<span style=color:#f92672>.</span>get_default_check_template_hash(self<span style=color:#f92672>.</span>context<span style=color:#f92672>.</span>nIn, self<span style=color:#f92672>.</span>context<span style=color:#f92672>.</span>precomputed_ctv_data):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>errors_with(errors<span style=color:#f92672>.</span>script_err_template_mismatch)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>return_as_nop()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># future upgrade can add semantics for this opcode with different length args</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># so discourage use when applicable</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>flags<span style=color:#f92672>.</span>script_verify_discourage_upgradable_nops:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>errors_with(errors<span style=color:#f92672>.</span>script_err_discourage_upgradable_nops)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>return_as_nop()
</span></span></code></pre></div><p>このハッシュの計算は、以下に示すように実装できます (ここで self はトランザクション型を指します)。どのような検証コンテキストでも、事前計算されたデータが初期化されていないとサービス妨害攻撃を招く可能性があるため注意が必要です。任意の実装は、二次元的なハッシュ計算による DoS を回避するために、これらのハッシュ計算部分をキャッシュしなければなりません。scriptsig、sequence、アウトプットなど可変長のすべての計算は事前計算を行う必要があります。詳細は「Denial of Service and Validation Costs」を参照してください。これは性能最適化ではありません。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ser_compact_size</span>(l):
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> l <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>253</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Serialize as unsigned char</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;B&#34;</span>, l)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> l <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x10000</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian)</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;BH&#34;</span>, <span style=color:#ae81ff>253</span>, l)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> l <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x100000000</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Serialize as unsigned char 254 followed by unsigned 4 byte integer (little endian)</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;BI&#34;</span>, <span style=color:#ae81ff>254</span>, l)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Serialize as unsigned char 255 followed by unsigned 8 byte integer (little endian)</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;BQ&#34;</span>, <span style=color:#ae81ff>255</span>, l)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> r
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ser_string</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ser_compact_size(len(s)) <span style=color:#f92672>+</span> s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CTxOut</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>serialize</span>(self):
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># serialize as signed 8 byte integer (little endian)</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;q&#34;</span>, self<span style=color:#f92672>.</span>nValue)
</span></span><span style=display:flex><span>        r <span style=color:#f92672>+=</span> ser_string(self<span style=color:#f92672>.</span>scriptPubKey)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> r
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_default_check_template_precomputed_data</span>(self):
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#75715e># If there are no scriptSigs we do not need to precompute a hash</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> any(inp<span style=color:#f92672>.</span>scriptSig <span style=color:#66d9ef>for</span> inp <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>vin):
</span></span><span style=display:flex><span>        result[<span style=color:#e6db74>&#34;scriptSigs&#34;</span>] <span style=color:#f92672>=</span> sha256(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(ser_string(inp<span style=color:#f92672>.</span>scriptSig) <span style=color:#66d9ef>for</span> inp <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>vin))
</span></span><span style=display:flex><span>    <span style=color:#75715e># The same value is also pre-computed for and defined in BIP-341 and can be shared.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># each nSequence is packed as 4 byte unsigned integer (little endian)</span>
</span></span><span style=display:flex><span>    result[<span style=color:#e6db74>&#34;sequences&#34;</span>] <span style=color:#f92672>=</span> sha256(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, inp<span style=color:#f92672>.</span>nSequence) <span style=color:#66d9ef>for</span> inp <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>vin))
</span></span><span style=display:flex><span>    <span style=color:#75715e># The same value is also pre-computed for and defined in BIP-341 and can be shared</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># See class CTxOut above for details.</span>
</span></span><span style=display:flex><span>    result[<span style=color:#e6db74>&#34;outputs&#34;</span>] <span style=color:#f92672>=</span> sha256(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(out<span style=color:#f92672>.</span>serialize() <span style=color:#66d9ef>for</span> out <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>vout))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># parameter precomputed must be passed in for DoS resistance</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_default_check_template_hash</span>(self, nIn, precomputed <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> precomputed <span style=color:#f92672>==</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        precomputed <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>get_default_check_template_precomputed_data()
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Serialize as 4 byte signed integer (little endian)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;i&#34;</span>, self<span style=color:#f92672>.</span>nVersion)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Serialize as 4 byte unsigned integer (little endian)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, self<span style=color:#f92672>.</span>nLockTime)
</span></span><span style=display:flex><span>    <span style=color:#75715e># we do not include the hash in the case where there is no</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># scriptSigs</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;scriptSigs&#34;</span> <span style=color:#f92672>in</span> precomputed:
</span></span><span style=display:flex><span>        r <span style=color:#f92672>+=</span> precomputed[<span style=color:#e6db74>&#34;scriptSigs&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Serialize as 4 byte unsigned integer (little endian)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, len(self<span style=color:#f92672>.</span>vin))
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> precomputed[<span style=color:#e6db74>&#34;sequences&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Serialize as 4 byte unsigned integer (little endian)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, len(self<span style=color:#f92672>.</span>vout))
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> precomputed[<span style=color:#e6db74>&#34;outputs&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Serialize as 4 byte unsigned integer (little endian)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, nIn)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sha256(r)
</span></span></code></pre></div><p>A PayToBareDefaultCheckTemplateVerifyHash output matches the following template:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Extra-fast test for pay-to-basic-standard-template CScripts:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_pay_to_bare_default_check_template_verify_hash</span>(self):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(self) <span style=color:#f92672>==</span> <span style=color:#ae81ff>34</span> <span style=color:#f92672>and</span> self[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x20</span> <span style=color:#f92672>and</span> self[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> OP_CHECKTEMPLATEVERIFY
</span></span></code></pre></div><h2 id=デプロイ>デプロイ<a hidden class=anchor aria-hidden=true href=#デプロイ>#</a></h2><p>この BIP からはアクティベーションロジックが省略されており、より適切な場所で議論されることが望ましいです。</p><p>BIP-119 が ACTIVE 状態に到達し、かつ SCRIPT_VERIFY_DEFAULT_CHECK_TEMPLATE_VERIFY_HASH フラグが施行されるまでは、ノード実装は （推奨される場合）NOP4 を実行するとして SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS (to deny entry to the mempool) によるポリシーを適用し、コンセンサス (during block validation). では NOP として評価されなければなりません。</p><p>CHECKTEMPLATEVERIFY を利用しやすくするため、a の一般的なケースとして scriptSig データを持たない PayToBareDefaultCheckTemplateVerifyHash が （推奨） スタンダード化されてリレーを許可するかもしれません。将来的にベアスクリプトは実装者の方針によるポリシー変更で標準化される可能性があります。</p><h2 id=参考実装>参考実装<a hidden class=anchor aria-hidden=true href=#参考実装>#</a></h2><p>リファレンス実装とテストはこちらの Bitcoin Core への PR で利用できます<br><a href=https://github.com/bitcoin/bitcoin/pull/21702>https://github.com/bitcoin/bitcoin/pull/21702</a>。</p><p>PR へのリンクはリベースや変更が行われる可能性があるため理想的ではありませんが、現在の実装や他者のレビューコメントを見つけるには最適な場所です。テストやベクタを含む最近のコミットハッシュはこちらにあります<br><a href=https://github.com/jeremyrubin/bitcoin/commit/3109df5616796282786706738994a5b97b8a5a38>https://github.com/jeremyrubin/bitcoin/commit/3109df5616796282786706738994a5b97b8a5a38</a>。PR がマージされたら、この BIP はリリースされたコードを指すように更新すべきです。</p><p>テストベクタは [/bip-0119/vectors the bip-0119/vectors directory] にあり、リファレンス実装や BIP との互換性チェックに使用できます。</p><h2 id=根拠>根拠<a hidden class=anchor aria-hidden=true href=#根拠>#</a></h2><p>OP_CHECKTEMPLATEVERIFY の設計はコードの変更点が少なく、解析が容易です。より複雑で安全性が実証可能なユースケースが必要になった場合に、新しいテンプレートタイプとの互換性もあります。</p><p>以下ではルールを一つずつ説明します。</p><h4 id=the-defaultchecktemplateverifyhash-of-the-transaction-at-the-current-input-index-matches-the-top-of-the-stack>The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack<a hidden class=anchor aria-hidden=true href=#the-defaultchecktemplateverifyhash-of-the-transaction-at-the-current-input-index-matches-the-top-of-the-stack>#</a></h4><p>コミットされるデータの集合は、トランザクションの TXID に影響を与える可能性があるデータのスーパーセットで、入力以外も含みます。これは、既知の入力がある場合に TXID をあらかじめ把握できるようにするためです。そうでなければ、CHECKTEMPLATEVERIFY はバッチ処理によるチャネル作成の構造では使用できません。これは、リデンプションの TXID が改変されて、事前署名されたトランザクションが無効化されてしまうからです。ただし、チャネルが LN-Symmetry のようなプロトコルで構築されている場合は別です。</p><p>ここで注意すべきは、事前署名されたコントラクトには、LN-Symmetry のようなものを利用できる場合と利用できない場合があることです。したがって、TXID を予測可能にしておくことで CTV は任意のサブプロトコルとより柔軟に組み合わせられるようになります。</p><h5 id=committing-to-the-version-and-locktime>Committing to the version and locktime<a hidden class=anchor aria-hidden=true href=#committing-to-the-version-and-locktime>#</a></h5><p>これらの値がコミットされていない場合、出力を恣意的に遅らせることが可能になるほか、TXID を変更することも可能になります。</p><p>これらの値を特定の値に制限するのではなくコミットすることは、CHECKTEMPLATEVERIFY の利用者がバージョンとロックタイムを自由に設定できるため、より柔軟です。</p><h5 id=committing-to-the-scriptsigs-hash>Committing to the ScriptSigs Hash<a hidden class=anchor aria-hidden=true href=#committing-to-the-scriptsigs-hash>#</a></h5><p>segwit トランザクションの scriptsig は完全に空でなければいけません。ただし、P2SH segwit トランザクションの場合は、正確な redeemscript のみ含んでいなければいけません。P2SH は (P2SH ハッシュが破られていない限り) CHECKTEMPLATEVERIFY とは互換性がありません。なぜならテンプレートハッシュが ScriptSig にコミットする必要があり、そこに含まれる redeemscript がハッシュサイクルとなるためです。</p><p>segwit インプットを使用しない場合のマリアビリティを防ぐためにも、scriptsig にコミットします。これによりレガシーの事前署名済み支出を 2 インプットの CHECKTEMPLATEVERIFY で使うことが可能になりますが、それにはレガシー出力の正確な scriptsig をコミットしておく必要があります。これは単に CHECKTEMPLATEVERIFY で設定する任意の scriptSig を不許可にするよりも堅牢です。</p><p>トランザクションに scriptSig が設定されていない場合、そのデータをハッシュしたり DefaultCheckTemplateVerifyHash に含めたりする意味はないため、省略します。segwit はマリアビリティを回避するために scriptSig を空にする必要があるので、scriptSig が設定されないことは一般的であると考えられます。</p><p>私たちは値そのものではなくハッシュにコミットしますが、これはすでに各トランザクションに対して事前に計算されており、SIGHASH_ALL シグネチャを最適化するためです。</p><p>さらに、ハッシュにコミットすることで、DefaultCheckTemplateVerifyHash をスクリプトから安全かつ明確に構築しやすくなります。</p><h5 id=インプット数へのコミット>インプット数へのコミット<a hidden class=anchor aria-hidden=true href=#インプット数へのコミット>#</a></h5><p>トランザクションで複数のインプットが使われることを許可すると、同じ出力のセットに対して 2 つの出力が支払いを要求できてしまい、意図した支払いの半分が破棄されてしまう「half-spend」問題が生じます。</p><p>さらに、どのインプットを同時に消費できるかの制限は、安定した TXID が必須となるペイメントチャネル構造において非常に重要です (アップデート時にはインプットのあらゆる組み合わせに署名する必要があります)。</p><p>しかし、複数のインプットを許可することには正当なユースケースもあります。例えば：</p><p>スクリプトパス：</p><pre tabindex=0><code>Path A: &lt;+24 hours&gt; OP_CHECKSEQUENCEVERIFY OP_CHECKTEMPLATEVERIFY &lt;Pay Alice 1 Bitcoin (1 input) nLockTime for +24 hours&gt;
Path B: OP_CHECKTEMPLATEVERIFY &lt;Pay Bob 2 Bitcoin (2 inputs)&gt;
</code></pre><p>この場合、出力には 24 時間があり、第二の出力を追加することで、Bob に 2 BTC を支払うことができます。もし 24 時間が経過した場合、Alice は契約から 1 BTC をリデームできます。どちらのインプット UTXO も同じ Path B を使用することも、片方のみが使用することも可能です。</p><p>これらの構成における問題は、インプットが並べられる順序が N! 通り存在し、その並び順を一般的な方法で制限することができない点です。</p><p>CHECKTEMPLATEVERIFY は、ユーザが消費されるインプットの正確な数を保証できるようにします。一般的に、CHECKTEMPLATEVERIFY を複数のインプットで使用するのは難しく、微妙な問題を引き起こす可能性があるため、特定のアプリケーション以外では複数インプットは使うべきではありません。</p><p>原則として、下記の Sequences Hash にコミットすることで、間接的にインプット数にもコミットされ、このフィールドは厳密には冗長になります。しかし、この数を個別にコミットすることで、スクリプトから DefaultCheckTemplateVerifyHash を構築しやすくなります。</p><p>私たちはインプットの数を <code>uint32_t</code> として扱いますが、これは Bitcoin のコンセンサスのデコードロジックがベクターを <code>MAX_SIZE=33554432</code> に制限しており、これは <code>uint16_t</code> より大きく、<code>uint32_t</code> より小さい値です。32 ビットは Bitcoin の現在の算術オペコードで操作するのにも適しています。もし <code>OP_CAT</code> が追加されればそれも可能です。なお、ブロック内の最大インプット数はブロックサイズによって約 25,000 に制限されており、<code>uint16_t</code> に収まりますが、それは不要な抽象化の漏洩です。</p><h5 id=シーケンスハッシュへのコミット>シーケンスハッシュへのコミット<a hidden class=anchor aria-hidden=true href=#シーケンスハッシュへのコミット>#</a></h5><p>シーケンスにコミットしない場合、TXID が改ざんされる可能性があります。これにより、相対的なシーケンスロックを OP_CSV を使用せずに適用できます。OP_CSV だけでは不十分です。なぜなら、OP_CSV はリテラルな値ではなく、nSequence の最小値を強制するだけだからです。</p><p>私たちは値そのものではなくハッシュにコミットします。これは各トランザクションごとに SIGHASH_ALL シグネチャを最適化するためにあらかじめ計算されているからです。ハッシュにコミットすることで、スクリプトから DefaultCheckTemplateVerifyHash を安全かつ明確に構築しやすくなります。</p><h5 id=アウトプット数へのコミット>アウトプット数へのコミット<a hidden class=anchor aria-hidden=true href=#アウトプット数へのコミット>#</a></h5><p>原則として、Outputs Hash (below) にコミットすることはアウトプット数にも暗黙的にコミットすることになり、このフィールドを厳密には冗長にします。しかし、この数に個別にコミットすると、スクリプトから DefaultCheckTemplateVerifyHash を構築しやすくなります。</p><p>アウトプットの数は <code>COutpoint</code> のインデックスが <code>uint32_t</code> であるため、<code>uint32_t</code> として扱います。さらに、Bitcoin のコンセンサスのデコードロジックではベクターを <code>MAX_SIZE=33554432</code> に制限しており、これは <code>uint16_t</code> より大きく、<code>uint32_t</code> より小さい値です。32 ビットはまた、Bitcoin の現在の数値オペコードを使用した操作にも適しており、<code>OP_CAT</code> が追加された場合にも対応しやすいです。</p><h5 id=アウトプットハッシュへのコミット>アウトプットハッシュへのコミット<a hidden class=anchor aria-hidden=true href=#アウトプットハッシュへのコミット>#</a></h5><p>これにより、UTXO を使用するときに要求されたとおりのアウトプットを確実に作成できるようになります。</p><p>私たちは、値そのものではなくハッシュにコミットします。これは、各トランザクションであらかじめ計算されており、SIGHASH_ALL シグネチャを最適化するために利用できるからです。ハッシュにコミットすることで、スクリプトから DefaultCheckTemplateVerifyHash を安全かつ明確に構築しやすくなります。</p><h5 id=現在のインプットのインデックスへのコミット>現在のインプットのインデックスへのコミット<a hidden class=anchor aria-hidden=true href=#現在のインプットのインデックスへのコミット>#</a></h5><p>現在実行中のインプットのインデックスにコミットすることは、厳密には改ざん耐性のために必要というわけではありません。しかし、これによってインプットの順序が制限され、プロトコル設計者にとっての改ざん可能性の要因を排除できます。</p><p>しかし、インデックスにコミットすることでハーフスペンド問題におけるキー再利用の脆弱性がなくなります。CHECKTEMPLATEVERIFY スクリプトは特定のインデックスで使用されるようコミットされるため、これらのスクリプトを再利用しても同じインデックスでは使用できません。つまり、同じトランザクションで使用することはできないことになります。これにより、ハーフスペンドの脆弱性がないウォレットボルト契約を設計しやすくなります。</p><p>現在のインデックスにコミットしても、複数のインデックスで使用可能な CHECKTEMPLATEVERIFY を表現することは妨げません。現在のスクリプトでは、CHECKTEMPLATEVERIFY オペレーションは各インデックスに対して OP_IF (または将来的には Tapscript のブランチ) でラップすることができます。もし OP_CAT または OP_SHA256STREAM が Bitcoin に追加される場合は、インデックスはハッシュ化の前に witness によって単純に渡される可能性があります。</p><h5 id=committing-to-values-by-hash>Committing to Values by Hash<a hidden class=anchor aria-hidden=true href=#committing-to-values-by-hash>#</a></h5><p>値をハッシュでコミットすることにより、スクリプトから DefaultCheckTemplateVerifyHash を構築することがより簡単かつ効率的になります。設定する予定のないフィールドは、再ハッシュの際に O(n) のオーバーヘッドが発生することなく、ハッシュでコミットすることができます。</p><p>さらに、将来的に OP_SHA256STREAM が追加される場合、スクリプト上でハッシュのミッドステートにコミットすることで、O(n) のオーバーヘッドを発生させずに単一の出力を出力のリストに追加できるスクリプトを書くことが可能になるかもしれません。</p><h5 id=using-sha256>Using SHA256<a hidden class=anchor aria-hidden=true href=#using-sha256>#</a></h5><p>SHA256 は 32 バイトのハッシュで、Bitcoin のセキュリティ標準を満たしており、テンプレートプログラムをプログラム的に作成するためにすでに Bitcoin Script 内で利用できます。</p><p>RIPEMD160 は 20 バイトのハッシュで、一部の文脈では有効なハッシュとなり得るだけでなく、いくつかの利点があります。手数料の効率面では、RIPEMD160 は 12 バイトを節約できます。しかし、RIPEMD160 は BIP-119 のためには選ばれませんでした。これは、サードパーティによって作成されるプログラムの検証に、トランザクションのプリイメージに対する [birthday-attack <a href=https://bitcoin.stackexchange.com/questions/54841/birthday-attack-on-p2sh>https://bitcoin.stackexchange.com/questions/54841/birthday-attack-on-p2sh</a>] のリスクをもたらすためです。</p><h5 id=using-non-tagged-hashes>Using Non-Tagged Hashes<a hidden class=anchor aria-hidden=true href=#using-non-tagged-hashes>#</a></h5><p>Taproot/Schnorr BIPs は Tagged Hashes ( <code>SHA256(SHA256(tag)||SHA256(tag)||msg)</code> ) を使用します。これは、taproot のリーフ、ブランチ、ツイーク、および署名が重複してセキュリティ上の [vulnerability <a href=https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-June/016091.html>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-June/016091.html</a>] を引き起こすのを防ぐためです。</p><p>OP_CHECKTEMPLATEVERIFY はこの種の脆弱性の影響を受けません。これらのハッシュは事実上外部でタグ付けされているので、つまり、OP_CHECKTEMPLATEVERIFY 自体によってタグが付与されているため、別のハッシュと混同されることはありません。</p><p>それをタグ付きハッシュにすることは、慎重な設計上の判断になるでしょう。たとえ明白な利点やコストがなかったとしてもです。しかし、将来的に OP_CAT が Bitcoin に導入された場合、動的に OP_CHECKTEMPLATEVERIFY ハッシュを組み立てるプログラムは空間効率が悪くなるでしょう。そのため、BIP-119 ではタグなしのハッシュが使われています。</p><h5 id=the-ordering-of-fields>The Ordering of Fields<a hidden class=anchor aria-hidden=true href=#the-ordering-of-fields>#</a></h5><p>厳密にいえば、フィールドの順序は重要ではありません。しかし、注意して選択された順序を用いることで、将来のスクリプト (e.g., OP_CAT や OP_SHA256STREAM を使うもの) の効率が向上する可能性があります (as described in the Future Upgrades section).</p><p>特に、この順序は変更される可能性が低いものから高いものへと並ぶように選択されています。</p><ol><li>nVersion</li><li>nLockTime</li><li>scriptSig hash (maybe!)</li><li>input count</li><li>sequences hash</li><li>output count</li><li>outputs hash</li><li>input index</li></ol><p>いくつかのフィールドはめったに変更されないです。nVersion はめったに変更されないはずです。nLockTime は通常 0 に固定するべきです (in the case of a payment tree, only the <em>first</em> lock time is needed to prevent fee-sniping the root)。scriptSig hash は通常まったく設定しないほうがいいです。</p><p>与えられた input count に対して可能な sequences hash が多数存在するため、input count は sequences hash の前に置かれます。与えられた out count に対して可能な outputs hash が多数存在するため、output count は outputs hash の前に置かれます。</p><p>通常、単一の入力から複数の出力を行う設計を使用しているため、inputs ハッシュよりも outputs ハッシュを変更する可能性が高いです。CHECKTEMPLATEVERIFY script では通常、入力が 1 つだけなので、input index を最後のフィールドにするのは意味がないように思えるかもしれません。しかし、「don&rsquo;t care」インデックスを簡単に表現できることの有用性 (e.g., for decentralized kickstarter-type transactions) を考えると、この値は最後に配置されています。</p><h3 id=設計上のトレードオフとリスク>設計上のトレードオフとリスク<a hidden class=anchor aria-hidden=true href=#設計上のトレードオフとリスク>#</a></h3><p>CHECKTEMPLATEVERIFY の設計はスクリプトの作成者を比較的厳密なテンプレート マッチングに制限します。CHECKTEMPLATEVERIFY テンプレートの構造は、入力を除いて、トランザクションの詳細の大部分を構築時に正確に把握しておく必要があります。</p><p>CHECKTEMPLATEVERIFY は入れ子にできます――つまり、あるトランザクションは created by spending an output with a <code>&lt;H> OP_CHECKTEMPLATEVERIFY</code> の制限がかかったアウトプットを使って支払うことで作成されると、<code>&lt;X> OP_CHECKTEMPLATEVERIFY</code> の制限がかかったアウトプットを新たに作成できます。</p><p>この拡張は本質的に有限です。なぜなら、<code>&lt;H></code> のハッシュを含むスクリプトを備えたアウトプットを、<code>&lt;H></code> のハッシュを持つアウトプットを使用して支払うトランザクションから再生成すると、ハッシュ サイクルが生じるからです。これは、各テンプレート ハッシュ <code>&lt;H></code> が、途切れなく続く可能性のある <code>OP_CHECKTEMPLATEVERIFY</code> 検証トランザクションの最も長い連鎖に対応する「path height」を持ち、その path height が厳密に減少する、と捉えられます。</p><p>さらに、テンプレートは特定の数のインプットとしてのみ支払えるように制限され、特定のインプット インデックスでのみ使用できるため、意図しない『half spend』問題の導入を防ぎます。</p><p>これほど制限されているテンプレートにも、いくつかのリスクが伴います。</p><h4 id=denial-of-service-and-validation-costs>Denial of Service and Validation Costs<a hidden class=anchor aria-hidden=true href=#denial-of-service-and-validation-costs>#</a></h4><p>CTV は DoS を発生させることなく非常に低コストで検証できるように設計されています。これは、あらかじめ計算されたハッシュをチェックするか、(some of which may be cached from more expensive computations) 固定長の引数をハッシュ化することで実現できます。</p><p>特に、CTV はクライアントがハッシュの計算をキャッシュすることを要求します。すべての scriptSig、sequence、および output に対して計算されるハッシュです。CTV 以前は、scriptSig のハッシュは必須ではありませんでした。CTV は非空の scriptSig をハッシュ化する必要がありますが、これは scriptSig のハッシュ処理の一部として扱うことができます。</p><p>したがって、コンセンサス中に CTV のハッシュを評価する場合のコストは、常に O(1) です。これはキャッシュが利用できる場合に限り成立する計算です。これらのキャッシュは通常、CHECKSIG の動作に関連する類似の問題のために必要となります。キャッシュの計算は O(T) (the size of the transaction) です。</p><p>キャッシュを行わない場合に DoS 問題が発生する可能性があるスクリプトの例は以下のとおりです：</p><pre tabindex=0><code>CTV CTV CTV... CTV
</code></pre><p>このようなスクリプトによって、インタープリタは (supposing N CTV&rsquo;s) の場合に O(N*T) のデータに対してハッシュを計算することになります。もし scriptSigs の非ヌル性がキャッシュされていない場合は、O(T) のトランザクションが O(N) 回走査される可能性もあります (although cheaper than hashing, still a DoS)。したがって、CTV はハッシュをキャッシュします。そしてトランザクション内のすべての可変長フィールドに対する計算結果もキャッシュします。</p><p>CTV（CheckTemplateVerify）において、サービス拒否（DoS）のリスクと検証コストは比較的明確です。実装者は、既存のキャッシュを活用し、CTVに新たに導入されるscriptSig上での計算をキャッシュするよう適切にコードを書く必要があります。より柔軟な提案では、より複雑なテンプレート計算がキャッシュしにくく、二乗的なハッシュ計算の問題を引き起こす可能性があるため、DoS問題への対処がより難しくなるでしょう。これは、柔軟性を犠牲にして低コストかつ安全な検証を優先するというCTVのトレードオフです。たとえば、もしCTVでビットマスクを利用して一部の出力のみをハッシュできるようにした場合、すべての出力パターンをキャッシュすることは不可能となり、二乗的ハッシュ計算によるDoSの脆弱性を引き起こすでしょう。</p><h4 id=永久に使用できない出力>永久に使用できない出力<a hidden class=anchor aria-hidden=true href=#永久に使用できない出力>#</a></h4><p>CHECKTEMPLATEVERIFY に渡されるプレイメージ引数は、不明であるか、または満たせない可能性があります。しかし、アドレスが使用可能であるという知識を要求するのは、送信者が任意のアドレス (特に OP_RETURN) に支払える能力と両立しません。もし送信者がテンプレートが送信前に使用可能かどうかを知る必要がある場合は、CHECKTEMPLATEVERIFY ツリーのリーフから、非トランザクションであることが証明可能なチャレンジ文字列への署名を要求できます。</p><h4 id=転送アドレス>転送アドレス<a hidden class=anchor aria-hidden=true href=#転送アドレス>#</a></h4><p>CHECKTEMPLATEVERIFY によるキーの再利用は、「forwarding address contract」の一形態として利用できます。転送アドレスとは、あらかじめ定義された方法で自動的に実行されるアドレスです。たとえば、ある取引所のホットウォレットは、そのアドレスを用いて、相対的なタイムアウト後にコールドストレージアドレスへ自動的に資金を移動できるようにすることができます。</p><p>この方法でアドレスを再利用すると資金を失う可能性があるという問題があります。1 BTC をコールドストレージに転送するテンプレートアドレスを作成すると仮定します。コールドストレージに転送するとします。このアドレスに 1 BTC 未満を送ろうとすると永久に凍結されます。1 BTC を超える金額を支払った場合、1 BTC を超える分は大きなマイナー手数料として支払われます。</p><p>CHECKTEMPLATEVERIFY は、入力によって提供される正確な bitcoin の額にコミットすることができるはずですが、これは利用者の誤りであって可鍛性の問題ではないため行われていません。将来的なソフトフォークでは、どのテンプレートやスクリプトのブランチをトランザクションに利用可能な資金の額を調べて判断できるような opcode を導入できる可能性があります。</p><p>一般的なベストプラクティスとして、Bitcoin の利用者はそのアドレスが意図した支払いに適切であると確信できない限り、いかなるアドレスも再利用しないようにする必要があります。この制限とリスクは CHECKTEMPLATEVERIFY に特有のものではありません。たとえば、atomic swap スクリプトは単一使用で、ハッシュが公開されると一度しか使用できません。将来の Taproot スクリプトには、多くの論理ブランチが含まれる可能性があり、それらは複数回使用すると安全でない（例として、Hash Time Lock ブランチはユニークなハッシュでインスタンス化する必要があります）。SIGHASH_ANYPREVOUT に署名した鍵もまた、再利用が危険になる可能性があります。</p><p>CHECKTEMPLATEVERIFY は、現在消費されている入力のインデックスにコミットしているため、再利用された鍵は必ず別々のトランザクションで実行され、「half-spend」タイプの問題のリスクを低減します。</p><h4 id=nop-default-and-recommended-standardness-rules>NOP-Default and Recommended Standardness Rules<a hidden class=anchor aria-hidden=true href=#nop-default-and-recommended-standardness-rules>#</a></h4><p>引数の長さが正確に 32 でない場合、CHECKTEMPLATEVERIFY はこれをコンセンサス検証時には NOP として扱います。実装では非コンセンサスの中継やメモリプール検証において、そのような状況下では失敗するようにすることが推奨されます。特に、無効な長さの引数を失敗にすることで将来のソフトフォークのアップグレードが、より厳しい標準的な制限に依存しながら、安全に標準性に関する制限を緩和できるようにしつつ、アップグレードのルールによってコンセンサスをより強化できるよう支援します。</p><p>標準性ルールは、悪意のあるスクリプト開発者が合意形成（consensus）時により厳格な標準性ルールが適用されると誤認してしまう恐れがあります。そのような開発者が標準性の拒否をあてにしてトランザクションをネットワークに直接送信した場合、標準性の観点では無効である一方、合意形成の観点では有効なトランザクションが作られ、資金を失うリスクにつながる可能性があります。</p><h4 id=機能の冗長性>機能の冗長性<a hidden class=anchor aria-hidden=true href=#機能の冗長性>#</a></h4><p>There are other opcodes that, if implemented, could make the CHECKTEMPLATEVERIFY の機能を冗長にする可能性があります。しかし、CHECKTEMPLATEVERIFY はシンプルな意味論とオンチェーンコストの低さから、たとえほかの機能と重複しても依然として好まれる可能性が高いです。</p><p>また、OP_VAULTやOP_CHECKCONTRACTVERIFY、OP_TXHASHなどのオペコードの場合、OP_CHECKTEMPLATEVERIFYは提案されている現在の実装の一部となっています。</p><p>より強力なオペコードとして、MES16で提案されているOP_COVやOP_TXHASHなどが挙げられます。これらは、外部的なchild-pays-for-parentやトランザクションスポンサーなどの手数料支払いメカニズムに依存するのではなく、内生的に手数料を支払う能力を高めるという点でいくつかの利点をもたらします。しかし、これらの機能は大幅に複雑性を増大させ、アプリケーション開発者が想定していない振る舞いが生じる可能性があります。</p><p>あるいは、SIGHASH_ANYPREVOUTANYSCRIPTを使用して、以下のようにscriptPubKeyを設定することでテンプレートに類似したものを実装することが可能です:</p><pre tabindex=0><code>&lt;sig of desired TX with PK and fixed nonce R || SIGHASH_ANYPREVOUTANYSCRIPT &lt;PK with public SK&gt;&gt; OP_CHECKSIG
</code></pre><p>上記のSIGHASH_ANYPREVOUTANYSCRIPTの機能はCHECKTEMPLATEVERIFYが提供するものに近いです。大きな違いとして、OP_CHECKTEMPLATEVERIFYは追加入力の数を制限し、動的に決定されるおつりの出力を認めない一方で、SIGHASH_ANYPREVOUTANYSCRIPTはSIGHASH_SINGLEやSIGHASH_ANYONECANPAYと組み合わせることができます。</p><p>さらに、OP_CHECKTEMPLATEVERIFYはscriptsigやsequenceにもコミットできるため、特定のP2SHスクリプト（またはsegwit v0 P2SH）を指定することができ、いくつかのユースケースで役立ちます。</p><p>加えて、CHECKTEMPLATEVERIFYにはスクリプトサイズの面での利点があります。（PKの選択にもよりますが、SIGHASH_ANYPREVOUTANYSCRIPTでは約2倍から3倍のバイト数を使用する場合があります。）また、署名操作ではなくハッシュ計算のみで済むため、検証速度の点でも有利です。これは大規模なペイメントツリーやプログラム的なコンパイルを構築する際に重要となる場合があります。さらに、CHECKTEMPLATEVERIFYには、将来的なテンプレートのアップグレードに対応する堅牢な道筋を提供するという機能的メリットもあり、これはOP_TXHASHでも提案されています。</p><p>OP_CHECKSIGFROMSTACKVERIFY と OP_CAT は、CHECKTEMPLATEVERIFY をエミュレートするためにも使用できます。しかし、そのような構成はアプリケーションスクリプトでの実装がCHECKTEMPLATEVERIFY よりも複雑になり、CHECKTEMPLATEVERIFY には存在しない追加の検証オーバーヘッドを伴います。</p><p>このアプローチは実装や分析が容易ですし、ユーザアプリケーションで得られるメリットもあるため、CHECKTEMPLATEVERIFY の単一テンプレートベースのアプローチは、スクリプトでトランザクションを指定するための汎用的なシステムの代わりに提案されています。</p><h4 id=将来的なアップグレード>将来的なアップグレード<a hidden class=anchor aria-hidden=true href=#将来的なアップグレード>#</a></h4><p>このセクションでは、将来的に考えられる OP_CHECKTEMPLATEVERIFY へのアップデートおよび、他の可能なアップグレードとのシナジーについて説明します。</p><h5 id=checktemplateverify-バージョン>CHECKTEMPLATEVERIFY バージョン<a hidden class=anchor aria-hidden=true href=#checktemplateverify-バージョン>#</a></h5><p>OP_CHECKTEMPLATEVERIFY は現在、32 バイトの引数の特性のみを検証します。将来的には、他の長さの引数にも意味を持たせることができます。たとえば、33 バイトの引数では、最後のバイトだけをコントロールプログラムとして利用できます。その場合、DefaultCheckTemplateVerifyHash はフラグバイトが CTVHASH_ALL に設定されている場合に計算されます。他のプログラムもSIGHASH_TYPE と同様に追加できます。たとえば、CTVHASH_GROUP はSIGHASH_GROUP との互換性のために Taproot Annex からデータを読み取り、どのインデックスがバンドルのためにハッシュされるかを動的に変更できるようにするなど、可能にします。</p><p>OP_TXHASH のプレ BIP で行われた作業は、OP_CHECKTEMPLATEVERIFY のセマンティクスを拡張するための 1 つのアプローチの詳細が示されています。</p><h5 id=op_checksigfromstackverify>OP_CHECKSIGFROMSTACKVERIFY<a hidden class=anchor aria-hidden=true href=#op_checksigfromstackverify>#</a></h5><p>OP_CHECKTEMPLATEVERIFY と OP_CHECKSIGFROMSTACKVERIFY の両方が Bitcoin に追加された場合、LN-Symmetry のフローティングトランザクションのバリアントを次のスクリプトで実装できるようになります:</p><pre tabindex=0><code>witness(S+n): &lt;sig&gt; &lt;H(tx with nLockTime S+n paying to program(S+n))&gt;
program(S): OP_CHECKTEMPLATEVERIFY &lt;musig_key(pk_update_a, pk_update_b)&gt; OP_CHECKSIGFROMSTACKVERIFY &lt;S+1&gt; OP_CHECKLOCKTIMEVERIFY
</code></pre><p>SIGHASH_ANYPREVOUTANYSCRIPT と比較すると、OP_CHECKTEMPLATEVERIFY は SIGHASH_ANYONECANPAY や SIGHASH_SINGLE に類する機能を許可していないため、プロトコル実装者は手数料を支払うため、Ephemeral Anchors や追加の Inputs を使ってトランザクションに署名するか、あるいはトランザクションスポンサーなどを検討するかもしれません。</p><h5 id=op_amountverify>OP_AMOUNTVERIFY<a hidden class=anchor aria-hidden=true href=#op_amountverify>#</a></h5><p>トランザクションで消費される正確な金額や、手数料として支払われる金額、特定の出力で使用可能になる金額を検証するオペコードは、より安全な OP_CHECKTEMPLATEVERIFY アドレスを実現するために利用できる可能性があります。たとえば、OP_CHECKTEMPLATEVERIFY のプログラム P がちょうど S satoshi を想定している場合、S-1 satoshi を送ると UTXO が凍結され、S+n satoshi を送ると n satoshi が手数料として支払われます。範囲チェックを行うことで、特定の値にのみプログラムを適用し、それ以外の場合はキー経路にフォールバックするように制限できるかもしれません。例：</p><pre tabindex=0><code>IF OP_AMOUNTVERIFY &lt;N&gt; OP_GREATER &lt;PK&gt; CHECKSIG
ELSE &lt;H&gt; OP_CHECKTEMPLATEVERIFY
</code></pre><h5 id=op_catop_sha256stream>OP_CAT/OP_SHA256STREAM<a hidden class=anchor aria-hidden=true href=#op_catop_sha256stream>#</a></h5><p>OP_CHECKTEMPLATEVERIFY は (as described in the Ordering of Fields section) Bitcoin が拡張されたデータ操作オペコードを得た場合に、スクリプトからトランザクションを動的に指定するために効率的です。</p><p>たとえば、以下のコードは入力インデックスの引数をチェックし、それをテンプレートに連結して、トランザクションがテンプレートに合致しているかを確認します。</p><pre tabindex=0><code>OP_SIZE 4 OP_EQUALVERIFY
&lt;nVersion || nLockTime || input count || sequences hash || output count || outputs hash&gt;
OP_SWAP OP_CAT OP_SHA256 OP_CHECKTEMPLATEVERIFY
</code></pre><p>なお、OP_CAT に例えば 520 バイトのサイズ制限が導入された場合、スクリプトの種類にもよりますが、12 個の入力と 12 個の出力を持つトランザクションを検査することしかできなくなります。</p><h2 id=backwards-compatibility>Backwards Compatibility<a hidden class=anchor aria-hidden=true href=#backwards-compatibility>#</a></h2><p>OP_CHECKTEMPLATEVERIFY は、より厳格な検証セマンティクスをもつ形で OP_NOP4 を置き換えます。そのため、以前は有効だったスクリプトは、この変更によって無効になる場合があります。OP_NOP に対してより厳格な検証セマンティクスを導入することはソフトフォークであり、既存のソフトウェアはマイニングやブロック検証を除いてアップグレードなしでも完全に機能します。OP_CHECKSEQUENCEVERIFY と OP_CHECKLOCKTIMEVERIFY (see BIP-0065 と BIP-0112) も同様に、互換性の問題を起こすことなく OP_NOP のセマンティクスを変更してきました。</p><p>これまでのフォークとは対照的に、OP_CHECKTEMPLATEVERIFY のリファレンス実装では、それを使用する支出スクリプトを含むトランザクションが 新しいルールがアクティブになるまで標準ポリシーの下でメモリプールに受理されたり中継されたりしません。他の実装にもこのルールに従うことが推奨されていますが、必須ではありません。</p><p>古いウォレットソフトウェアは、OP_CHECKTEMPLATEVERIFY アウトプットからの支払いを受け付けられますが、確定済みの先祖を持つ PayToBareDefaultCheckTemplateVerifyHash チェーンを「信頼済み」(つまり、トランザクションが承認される前に支出可能 であるもの)として扱うにはアップグレードが必要になります。</p><p>OP_CHECKTEMPLATEVERIFY のバックポートは (リファレンス実装を参照) 古いノードバージョン向けに簡単に用意できますが、それらはパッチ適用はできても新しいメジャーリリースへのアップグレードはできません。</p><h2 id=スクリプト互換性>スクリプト互換性<a hidden class=anchor aria-hidden=true href=#スクリプト互換性>#</a></h2><p>OP_CHECKTEMPLATEVERIFY はすべてのスクリプトバージョンで利用可能です。アプリケーション開発者は、scriptSig でプログラムが露出する P2SH および P2SH Segwit では、scriptSig 内でプログラムが公開されるこれらの場合、プログラム内で<code>&lt;H> CTV</code> のようなフラグメントを使用できません。scriptSig のコミットメントがハッシュサイクルを引き起こすためです。</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://utxos.org>utxos.org 情報サイト</a></li><li><a href=https://covenants.info>covenants.info 情報サイト</a></li><li><a href=https://learn.sapio-lang.org>Sapio ビットコイン スマートコントラクト言語</a></li><li><a href=https://rubin.io/advent21>27 Blog Posts on building smart contracts with Sapio and CTV, including examples described here.</a></li><li><a href="https://www.youtube.com/watch?v=YxsjdIl0034&amp;t=2451">Scaling Bitcoin Presentation</a></li><li><a href=https://bitcoinops.org/en/newsletters/2019/05/29/>Optech Newsletter Covering OP_CHECKOUTPUTSHASHVERIFY</a></li><li><a href=https://cyber.stanford.edu/sites/g/files/sbiybj9936/f/jeremyrubin.pdf>Structuring Multi Transaction Contracts in Bitcoin</a></li><li><a href=https://github.com/jeremyrubin/lazuli>Lazuli Notes (ECDSA based N-of-N Signatures for Certified Post-Dated UTXOs)</a></li><li><a href=https://fc16.ifca.ai/bitcoin/papers/MES16.pdf>Bitcoin Covenants</a></li><li><a href="https://bitcointalk.org/index.php?topic=278122.0">CoinCovenants using SCIP signatures, an amusingly bad idea.</a></li><li><a href=https://fc17.ifca.ai/bitcoin/papers/bitcoin17-final28.pdf>Enhancing Bitcoin Transactions with Covenants</a></li><li><a href=https://github.com/jamesob/simple-ctv-vault>Simple CTV Vaults</a></li><li><a href=https://github.com/kanzure/python-vaults>Python Vaults</a></li><li><a href=https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019808.html>CTV Dramatically Improves DLCs</a></li><li><a href=https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020225.html>Calculus of Covenants</a></li><li><a href=https://rubin.io/bitcoin/2021/12/10/advent-13/>Payment Pools with CTV</a></li><li><a href=https://rubin.io/bitcoin/2021/12/11/advent-14/>Channels with CTV</a></li><li><a href=https://rubin.io/bitcoin/2021/12/09/advent-12/>Congestion Control with CTV</a></li><li><a href=https://rubin.io/bitcoin/2021/12/07/advent-10/>Building Vaults on Bitcoin</a></li><li><a href=https://arkdev.info/>(Ark Labs) Ark Documentation</a></li><li><a href=https://docs.second.tech/protocol/intro/>(Second) Ark Documentation</a></li><li><a href=https://rubin.io/bitcoin/2022/09/14/drivechain-apo/>SpookChains</a></li><li><a href=https://github.com/bitcoin/bips/pull/1500>OP_TXHASH</a></li></ul><h3 id=類似した代替案について>類似した代替案について<a hidden class=anchor aria-hidden=true href=#類似した代替案について>#</a></h3><p>CHECKTEMPLATEVERIFY の以前のバージョンである CHECKOUTPUTSHASHVERIFY は CHECKTEMPLATEVERIFY を優先するために取り下げられました。CHECKOUTPUTSHASHVERIFY はバージョンやロックタイムにコミットしていなかったため、安全ではありませんでした。</p><p>CHECKTEMPLATEVERIFY は Taproot への拡張として実装することも可能で、これまでもこの方法で提案されていました。ただし、特定のアプリケーションは bare legacy スクリプトで OP_CHECKTEMPLATEVERIFY を使用して効率を最大化したい場合があります。</p><p>CHECKTEMPLATEVERIFY は以前に次の名称でも呼ばれていました OP_SECURETHEBAG として言及されており、ここではこの BIP に関する検索や議論を参照するのに役立てるために記載しています。</p><h2 id=著作権>著作権<a hidden class=anchor aria-hidden=true href=#著作権>#</a></h2><p>このドキュメントは 3-clause BSD license の下でライセンスされています。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yusukeshimizu.github.io/blog/>blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>