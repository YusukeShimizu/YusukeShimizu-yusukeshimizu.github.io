<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on blog</title><link>https://yusukeshimizu.github.io/blog/posts/</link><description>Recent content in Posts on blog</description><generator>Hugo -- 0.145.0</generator><language>en</language><lastBuildDate>Sat, 22 Mar 2025 08:56:49 +0900</lastBuildDate><atom:link href="https://yusukeshimizu.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>bip-0119</title><link>https://yusukeshimizu.github.io/blog/posts/bip-0119-ja/</link><pubDate>Sat, 22 Mar 2025 08:56:49 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/bip-0119-ja/</guid><description>&lt;p>BIP 119の日本語訳をおいておく。&lt;/p>
&lt;p>この記事は、llmにより翻訳されたものであり、内容に誤りがある可能性はある。&lt;br>
BIP 119は、新しいオペコード OP_CHECKTEMPLATEVERIFY を有効化することを提案しており、このブログを書いた段階で、有力な選択肢となっている。&lt;br>
&lt;a href="https://www.coindesk.com/tech/2025/03/17/developer-consensus-may-be-converging-on-a-bitcoin-soft-fork-proposal-blockspace">Developer Consensus May Be Converging on a Bitcoin Soft Fork Proposal: Blockspace&lt;/a>&lt;/p>
&lt;p>なお、この記事は、commit hash&lt;a href="https://github.com/bitcoin/bips/blob/88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f/bip-0119.mediawiki">88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f&lt;/a> 時点のものとなっている。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#abstract">Abstract&lt;/a>&lt;/li>
&lt;li>&lt;a href="#summary">Summary&lt;/a>&lt;/li>
&lt;li>&lt;a href="#motivation">Motivation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#detailed-specification">Detailed Specification&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4">デプロイ&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E8%80%83%E5%AE%9F%E8%A3%85">参考実装&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%A0%B9%E6%8B%A0">根拠&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#the-defaultchecktemplateverifyhash-of-the-transaction-at-the-current-input-index-matches-the-top-of-the-stack">The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#committing-to-the-version-and-locktime">Committing to the version and locktime&lt;/a>&lt;/li>
&lt;li>&lt;a href="#committing-to-the-scriptsigs-hash">Committing to the ScriptSigs Hash&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%82%A4%E3%83%B3%E3%83%97%E3%83%83%E3%83%88%E6%95%B0%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88">インプット数へのコミット&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%82%B7%E3%83%BC%E3%82%B1%E3%83%B3%E3%82%B9%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88">シーケンスハッシュへのコミット&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%82%A2%E3%82%A6%E3%83%88%E3%83%97%E3%83%83%E3%83%88%E6%95%B0%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88">アウトプット数へのコミット&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%82%A2%E3%82%A6%E3%83%88%E3%83%97%E3%83%83%E3%83%88%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88">アウトプットハッシュへのコミット&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%8F%BE%E5%9C%A8%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%97%E3%83%83%E3%83%88%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88">現在のインプットのインデックスへのコミット&lt;/a>&lt;/li>
&lt;li>&lt;a href="#committing-to-values-by-hash">Committing to Values by Hash&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-sha256">Using SHA256&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-non-tagged-hashes">Using Non-Tagged Hashes&lt;/a>&lt;/li>
&lt;li>&lt;a href="#the-ordering-of-fields">The Ordering of Fields&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E8%A8%AD%E8%A8%88%E4%B8%8A%E3%81%AE%E3%83%88%E3%83%AC%E3%83%BC%E3%83%89%E3%82%AA%E3%83%95%E3%81%A8%E3%83%AA%E3%82%B9%E3%82%AF">設計上のトレードオフとリスク&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#denial-of-service-and-validation-costs">Denial of Service and Validation Costs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%B0%B8%E4%B9%85%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E5%87%BA%E5%8A%9B">永久に使用できない出力&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E8%BB%A2%E9%80%81%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">転送アドレス&lt;/a>&lt;/li>
&lt;li>&lt;a href="#nop-default-and-recommended-standardness-rules">NOP-Default and Recommended Standardness Rules&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%A9%9F%E8%83%BD%E3%81%AE%E5%86%97%E9%95%B7%E6%80%A7">機能の冗長性&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%B0%86%E6%9D%A5%E7%9A%84%E3%81%AA%E3%82%A2%E3%83%83%E3%83%97%E3%82%B0%E3%83%AC%E3%83%BC%E3%83%89">将来的なアップグレード&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#checktemplateverify-%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3">CHECKTEMPLATEVERIFY バージョン&lt;/a>&lt;/li>
&lt;li>&lt;a href="#op_checksigfromstackverify">OP_CHECKSIGFROMSTACKVERIFY&lt;/a>&lt;/li>
&lt;li>&lt;a href="#op_amountverify">OP_AMOUNTVERIFY&lt;/a>&lt;/li>
&lt;li>&lt;a href="#op_catop_sha256stream">OP_CAT/OP_SHA256STREAM&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#backwards-compatibility">Backwards Compatibility&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E4%BA%92%E6%8F%9B%E6%80%A7">スクリプト互換性&lt;/a>&lt;/li>
&lt;li>&lt;a href="#references">References&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E9%A1%9E%E4%BC%BC%E3%81%97%E3%81%9F%E4%BB%A3%E6%9B%BF%E6%A1%88%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">類似した代替案について&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E8%91%97%E4%BD%9C%E6%A8%A9">著作権&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>BIP: 119&lt;br>
Layer: Consensus (soft fork)&lt;br>
Title: CHECKTEMPLATEVERIFY&lt;br>
Author: Jeremy Rubin &lt;a href="mailto:j@rubin.io">j@rubin.io&lt;/a>&lt;br>
Comments-URI: &lt;a href="https://github.com/bitcoin/bips/wiki/Comments:BIP-0119">https://github.com/bitcoin/bips/wiki/Comments:BIP-0119&lt;/a>&lt;br>
Status: Draft&lt;br>
Type: Standards Track&lt;br>
Created: 2020-01-06&lt;br>
License: BSD-3-Clause&lt;/p></description></item><item><title>[podcast]Covenants Everything</title><link>https://yusukeshimizu.github.io/blog/posts/Covenants_everything/</link><pubDate>Fri, 21 Mar 2025 16:07:31 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/Covenants_everything/</guid><description>&lt;p>&lt;a href="https://www.adoptblock.com/covenants-op-cat-op-ctv-english">https://www.adoptblock.com/covenants-op-cat-op-ctv-english&lt;/a> をinputとし、podcastfyを用いて作成したもの。
&lt;code>gpt-4o-mini-tts&lt;/code>を使うことで実用に耐える音声品質になった。&lt;/p>
&lt;figure >
&lt;audio controls preload="metadata">
&lt;source src="https://yusukeshimizu.github.io/blog/covenants.mp3" type="audio/mpeg">
&lt;/audio>
&lt;/figure>
&lt;hr>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>ビットコインのスケーラビリティ課題とKaspaとの比較&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>ビットコインのSidechainやLightningなどの拡張方法&lt;/li>
&lt;li>Kaspaは高速だが、フルノードでない点がセキュリティ上の妥協になる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ビットコインScriptとコヴナンツ入門&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>UTXOモデルとスタックベースの簡素な言語設計&lt;/li>
&lt;li>コヴナンツ（Covenants）で“UTXOの使い方”を厳しく制限・管理できるアイデア&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>主なコヴナンツの種類と特徴&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>トランザクションのハッシュ検証型、トランザクション内容検証型など&lt;/li>
&lt;li>再帰的に制限をかけることで、予期せぬ流動性の低下やファンジビリティ低下リスクがある&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>OPコード（オペコード）の拡張&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>過去に無効化されたOP_CAT再導入と、そのメリット・懸念&lt;/li>
&lt;li>OP_CHECKTEMPLATEVERIFY (OP_CTV) などのシンプルなコヴナンツ実装案&lt;/li>
&lt;li>それぞれのアプローチのトレードオフ（柔軟性と安全性のバランス）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ライトニングネットワークやEltooとの関係&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>ANYPREVOUT (BIP-118) でチャネル管理をシンプル化&lt;/li>
&lt;li>Vaultのアイデアなど、資金盗難への対抗策も議論される&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ビットコイン開発の進め方&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>SegWitやTaprootの導入にも長いテストと合意形成が必要だった&lt;/li>
&lt;li>大規模変更ほど、実装リスクとコミュニティの議論に時間を要する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>今後の展望と注意点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>コヴナンツ導入でDeFi的な活用も見据えられる&lt;/li>
&lt;li>ただし、BTCのファンジビリティや可用性を損なう恐れもあり、慎重な検証が必須&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Github Copilot Chat Commit Message Rules</title><link>https://yusukeshimizu.github.io/blog/posts/github-copilot-chat-commit-message-rules/</link><pubDate>Fri, 21 Mar 2025 09:28:58 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/github-copilot-chat-commit-message-rules/</guid><description>&lt;p>コミットメッセージを標準化するには、&lt;code>github.copilot.chat.commitMessageGeneration.instructions&lt;/code>を設定し、Copilot Chatが常に所定のルールに従うよう誘導するのが効果的である。たとえば、以下のように&lt;code>.vscode/settings.json&lt;/code>に記述する。&lt;/p>
&lt;p>他にも多様な方法があるが、ボタンをクリックするだけで設定できるため、結局これが使われていることが多いように思われる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsonc" data-lang="jsonc">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;github.copilot.chat.commitMessageGeneration.instructions&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;text&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;以下のルールに従ってコミットメッセージを生成:\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;1) 1行目は50文字以内\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;2) 本文が必要なら72文字幅で改行し、1行目と本文の間に空行\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;3) 現在形で書く (例: &amp;#39;Fix bug&amp;#39;, &amp;#39;Add feature&amp;#39;)\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;4) サブシステムやパッケージ名を先頭に (例: &amp;#39;wallet: &amp;#39;)\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;5) 箇条書きはハイフン(-)またはアスタリスク(*)で始める\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;6) 最後に &amp;#39;Generated by Copilot&amp;#39; と記載&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Copilot Chatは、この設定を参照してコミットメッセージを提案する。結果として、コミットメッセージの書式を一貫させ、読みやすい履歴管理を実現できる。commitlintなどと併用すれば、さらに厳格なバリデーションを行うことが可能である。&lt;/p></description></item><item><title>Wifi Off</title><link>https://yusukeshimizu.github.io/blog/posts/wifi-off/</link><pubDate>Fri, 21 Mar 2025 08:56:49 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/wifi-off/</guid><description>&lt;p>Wi-Fiを強制的にオフにすべきである。ネットからの通知やチャットへの意識を一掃し、思考を乱す要因を遮断できるからである。プログラミングや文章作成など、深い集中が必要な作業では特に有効である。&lt;/p>
&lt;p>Wi-Fiを切る前に必要資料をあらかじめ開いておくことが望ましい。ネット接続が必要な箇所は作業後にまとめて調べるべきである。スクリプトを用いれば、一定時間オフにしたまま強制的に待機できる。たとえばmacOSでは、以下のワンライナーが使える。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>networksetup -setairportpower en0 off &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sleep &lt;span style="color:#ae81ff">1800&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>networksetup -setairportpower en0 on &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>osascript -e &lt;span style="color:#e6db74">&amp;#39;display notification &amp;#34;WiFiが復活しました&amp;#34; with title &amp;#34;通知&amp;#34;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>資料を読み込み、作業に没頭し、後で必要部分のみ確認すればよい。緊急の連絡が想定される場合は注意が必要だが、そうでないならオフラインで集中すべきである。この手法によってフロー状態を維持しやすくなり、結果的に作業効率が上がると断言できる。&lt;/p></description></item><item><title>Greenlight における Scheduler と Signer/HSM のアーキテクチャ</title><link>https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/</link><pubDate>Wed, 19 Mar 2025 11:07:52 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/</guid><description>&lt;p>&lt;a href="https://github.com/Blockstream/greenlight/tree/adac70212c70119cc7e7174a742133e14dcdea0a/libs/proto/glclient">greenlight proto&lt;/a> をベースにした解説。&lt;/p>
&lt;p>greenlightはLightning Network（LN）の運用を簡易化するためのサービスである。しかし、どこが自己ホスト（self host）で、どこに信頼を置く必要があるのかが分かりにくい。SchedulerはLNノードの管理やスケジューリング機能を担うが、これは非公開のコードで動作し、ユーザーはその内部を直接検証できない。一方、Signerはトランザクション署名を行う重要なコンポーネントであり、cln（Core Lightning）はLightning Networkの実装である。これらは公開リポジトリとして誰でも参照できる。&lt;/p>
&lt;p>&lt;strong>目的と結論&lt;/strong>&lt;br>
Greenlight では、Scheduler (Closed Source) が Node 管理の中心にあり、UserClient (with integrated Signer/HSM) が Self-Hosted 環境で秘密鍵を保持する構造をとる。結論として、UserClient 側が鍵操作を制御しつつ、Greenlight 側の Scheduler が Node (CLN) を起動・管理する。これにより、秘密鍵をローカルで保持したまま Node をリモートで稼働させる運用が可能となる。&lt;/p>
&lt;hr>
&lt;h2 id="全体構造">全体構造&lt;/h2>
&lt;p>以下の図に示すように、UserClient (with integrated Signer/HSM) は自前の環境 (Self-Hosted) で動作する。一方、Scheduler は Greenlight が管理し、CLN (c-lightning+plugin) も Greenlight Hosted 環境で稼働する。UserClient は Scheduler に対して Manage API call を行い、Node に対する操作は Scheduler が CLN を経由して実行する。Signer/HSM は秘密鍵をローカルで保持し、署名要求のみを受け付ける。&lt;/p>
&lt;pre tabindex="0">&lt;code>(Self-Hosted) (Greenlight Hosted)
+-----------------------------------+ (Manage API call) +----------------------------+
| UserClient (with integrated | --------------------&amp;gt; | Scheduler (Closed Source) |
| Signer / HSM) | +-------------+--------------+
+-----------------------------------+ |
| (Node management)
| v
| +------------------------+
|-----------------------&amp;gt; |CLN (c-lightning+plugin)|
+-----------+------------+
&lt;/code>&lt;/pre>&lt;hr>
&lt;h2 id="ノード登録とスケジューリングフロー">ノード登録とスケジューリングフロー&lt;/h2>
&lt;h3 id="チャレンジ発行-getchallenge">チャレンジ発行 (GetChallenge)&lt;/h3>
&lt;ol>
&lt;li>スコープ (REGISTER や RECOVER) と node_id を指定し、Scheduler に GetChallenge をコールする。&lt;/li>
&lt;li>Scheduler は一度きり有効な challenge を生成し、ChallengeResponse に含めて返す。&lt;/li>
&lt;/ol>
&lt;h3 id="register--recover">Register / Recover&lt;/h3>
&lt;ol>
&lt;li>クライアントは challenge を秘密鍵で署名し、node_id、network、CSR などと共に送信する。&lt;/li>
&lt;li>Scheduler は署名検証後にノード所有権を確認し、mTLS のための device_cert と device_key を発行する。&lt;/li>
&lt;li>Register は新規発行、Recover は既存ノードの証明書再発行となる。&lt;/li>
&lt;/ol>
&lt;h3 id="schedule--getnodeinfo">Schedule / GetNodeInfo&lt;/h3>
&lt;ol>
&lt;li>クライアントは Schedule を呼び出し、ノード起動をリクエストする。&lt;/li>
&lt;li>Scheduler は CLN を割り当て、grpc_uri など接続情報を返す。&lt;/li>
&lt;li>すでに起動済みの場合、GetNodeInfo で接続情報を取得可能である。&lt;/li>
&lt;/ol>
&lt;h3 id="接続操作">接続・操作&lt;/h3>
&lt;ol>
&lt;li>クライアントは取得した device_cert と device_key を用い、mTLS で CLN (node) に接続する。&lt;/li>
&lt;li>支払いやチャネル操作などの RPC 呼び出しを行う。&lt;/li>
&lt;li>署名が必要な場合、CLN は Signer (HSM) へ HsmRequest を送信し、秘密鍵を外部に渡さずに署名のみを実行する。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="signer-フロー-hsmrequest--hsmservice">Signer フロー (HSMRequest / HsmService)&lt;/h2>
&lt;p>CLN は秘密鍵が必要なとき、Node Service の StreamHsmRequests を用いて外部サイナー (Signer/HSM) へ HsmRequest を通知する。Signer はローカルで署名を実施し、HsmResponse で返す。具体的な流れは以下の通りである。&lt;/p></description></item></channel></rss>