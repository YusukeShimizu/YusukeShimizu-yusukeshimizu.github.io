<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on blog</title><link>https://yusukeshimizu.github.io/blog/posts/</link><description>Recent content in Posts on blog</description><generator>Hugo -- 0.145.0</generator><language>en</language><lastBuildDate>Fri, 21 Mar 2025 16:07:31 +0900</lastBuildDate><atom:link href="https://yusukeshimizu.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>covenants everything</title><link>https://yusukeshimizu.github.io/blog/posts/Covenants_everything/</link><pubDate>Fri, 21 Mar 2025 16:07:31 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/Covenants_everything/</guid><description>&lt;p>&lt;a href="https://www.adoptblock.com/covenants-op-cat-op-ctv-english">https://www.adoptblock.com/covenants-op-cat-op-ctv-english&lt;/a> を、日本語に翻訳し、 &lt;a href="https://github.com/souzatharsis/podcastfy">https://github.com/souzatharsis/podcastfy&lt;/a> を用いて音声化したもの。&lt;/p>
&lt;p>&lt;a href="https://www.openai.fm/">https://www.openai.fm/&lt;/a> で公開されているように、&lt;code>gpt-4o-mini-tts&lt;/code>を使うことで実用に耐える音声品質になった。&lt;/p>
&lt;figure >
&lt;audio controls preload="metadata">
&lt;source src="https://yusukeshimizu.github.io/blog/covenants.mp3" type="audio/mpeg">
&lt;/audio>
&lt;/figure></description></item><item><title>Github Copilot Chat Commit Message Rules</title><link>https://yusukeshimizu.github.io/blog/posts/github-copilot-chat-commit-message-rules/</link><pubDate>Fri, 21 Mar 2025 09:28:58 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/github-copilot-chat-commit-message-rules/</guid><description>&lt;p>コミットメッセージを標準化するには、&lt;code>github.copilot.chat.commitMessageGeneration.instructions&lt;/code>を設定し、Copilot Chatが常に所定のルールに従うよう誘導するのが効果的である。たとえば、以下のように&lt;code>.vscode/settings.json&lt;/code>に記述する。&lt;/p>
&lt;p>他にも多様な方法があるが、ボタンをクリックするだけで設定できるため、結局これが使われていることが多いように思われる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsonc" data-lang="jsonc">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;github.copilot.chat.commitMessageGeneration.instructions&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;text&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;以下のルールに従ってコミットメッセージを生成:\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;1) 1行目は50文字以内\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;2) 本文が必要なら72文字幅で改行し、1行目と本文の間に空行\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;3) 現在形で書く (例: &amp;#39;Fix bug&amp;#39;, &amp;#39;Add feature&amp;#39;)\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;4) サブシステムやパッケージ名を先頭に (例: &amp;#39;wallet: &amp;#39;)\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;5) 箇条書きはハイフン(-)またはアスタリスク(*)で始める\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;6) 最後に &amp;#39;Generated by Copilot&amp;#39; と記載&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Copilot Chatは、この設定を参照してコミットメッセージを提案する。結果として、コミットメッセージの書式を一貫させ、読みやすい履歴管理を実現できる。commitlintなどと併用すれば、さらに厳格なバリデーションを行うことが可能である。&lt;/p></description></item><item><title>Wifi Off</title><link>https://yusukeshimizu.github.io/blog/posts/wifi-off/</link><pubDate>Fri, 21 Mar 2025 08:56:49 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/wifi-off/</guid><description>&lt;p>Wi-Fiを強制的にオフにすべきである。ネットからの通知やチャットへの意識を一掃し、思考を乱す要因を遮断できるからである。プログラミングや文章作成など、深い集中が必要な作業では特に有効である。&lt;/p>
&lt;p>Wi-Fiを切る前に必要資料をあらかじめ開いておくことが望ましい。ネット接続が必要な箇所は作業後にまとめて調べるべきである。スクリプトを用いれば、一定時間オフにしたまま強制的に待機できる。たとえばmacOSでは、以下のワンライナーが使える。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>networksetup -setairportpower en0 off &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sleep &lt;span style="color:#ae81ff">1800&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>networksetup -setairportpower en0 on &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>osascript -e &lt;span style="color:#e6db74">&amp;#39;display notification &amp;#34;WiFiが復活しました&amp;#34; with title &amp;#34;通知&amp;#34;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>資料を読み込み、作業に没頭し、後で必要部分のみ確認すればよい。緊急の連絡が想定される場合は注意が必要だが、そうでないならオフラインで集中すべきである。この手法によってフロー状態を維持しやすくなり、結果的に作業効率が上がると断言できる。&lt;/p></description></item><item><title>Greenlight における Scheduler と Signer/HSM のアーキテクチャ</title><link>https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/</link><pubDate>Wed, 19 Mar 2025 11:07:52 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/</guid><description>&lt;p>&lt;a href="https://github.com/Blockstream/greenlight/tree/adac70212c70119cc7e7174a742133e14dcdea0a/libs/proto/glclient">greenlight proto&lt;/a> をベースにした解説。&lt;/p>
&lt;p>greenlightはLightning Network（LN）の運用を簡易化するためのサービスである。しかし、どこが自己ホスト（self host）で、どこに信頼を置く必要があるのかが分かりにくい。SchedulerはLNノードの管理やスケジューリング機能を担うが、これは非公開のコードで動作し、ユーザーはその内部を直接検証できない。一方、Signerはトランザクション署名を行う重要なコンポーネントであり、cln（Core Lightning）はLightning Networkの実装である。これらは公開リポジトリとして誰でも参照できる。&lt;/p>
&lt;p>&lt;strong>目的と結論&lt;/strong>&lt;br>
Greenlight では、Scheduler (Closed Source) が Node 管理の中心にあり、UserClient (with integrated Signer/HSM) が Self-Hosted 環境で秘密鍵を保持する構造をとる。結論として、UserClient 側が鍵操作を制御しつつ、Greenlight 側の Scheduler が Node (CLN) を起動・管理する。これにより、秘密鍵をローカルで保持したまま Node をリモートで稼働させる運用が可能となる。&lt;/p>
&lt;hr>
&lt;h2 id="全体構造">全体構造&lt;/h2>
&lt;p>以下の図に示すように、UserClient (with integrated Signer/HSM) は自前の環境 (Self-Hosted) で動作する。一方、Scheduler は Greenlight が管理し、CLN (c-lightning+plugin) も Greenlight Hosted 環境で稼働する。UserClient は Scheduler に対して Manage API call を行い、Node に対する操作は Scheduler が CLN を経由して実行する。Signer/HSM は秘密鍵をローカルで保持し、署名要求のみを受け付ける。&lt;/p>
&lt;pre tabindex="0">&lt;code>(Self-Hosted) (Greenlight Hosted)
+-----------------------------------+ (Manage API call) +----------------------------+
| UserClient (with integrated | --------------------&amp;gt; | Scheduler (Closed Source) |
| Signer / HSM) | +-------------+--------------+
+-----------------------------------+ |
| (Node management)
| v
| +------------------------+
|-----------------------&amp;gt; |CLN (c-lightning+plugin)|
+-----------+------------+
&lt;/code>&lt;/pre>&lt;hr>
&lt;h2 id="ノード登録とスケジューリングフロー">ノード登録とスケジューリングフロー&lt;/h2>
&lt;h3 id="チャレンジ発行-getchallenge">チャレンジ発行 (GetChallenge)&lt;/h3>
&lt;ol>
&lt;li>スコープ (REGISTER や RECOVER) と node_id を指定し、Scheduler に GetChallenge をコールする。&lt;/li>
&lt;li>Scheduler は一度きり有効な challenge を生成し、ChallengeResponse に含めて返す。&lt;/li>
&lt;/ol>
&lt;h3 id="register--recover">Register / Recover&lt;/h3>
&lt;ol>
&lt;li>クライアントは challenge を秘密鍵で署名し、node_id、network、CSR などと共に送信する。&lt;/li>
&lt;li>Scheduler は署名検証後にノード所有権を確認し、mTLS のための device_cert と device_key を発行する。&lt;/li>
&lt;li>Register は新規発行、Recover は既存ノードの証明書再発行となる。&lt;/li>
&lt;/ol>
&lt;h3 id="schedule--getnodeinfo">Schedule / GetNodeInfo&lt;/h3>
&lt;ol>
&lt;li>クライアントは Schedule を呼び出し、ノード起動をリクエストする。&lt;/li>
&lt;li>Scheduler は CLN を割り当て、grpc_uri など接続情報を返す。&lt;/li>
&lt;li>すでに起動済みの場合、GetNodeInfo で接続情報を取得可能である。&lt;/li>
&lt;/ol>
&lt;h3 id="接続操作">接続・操作&lt;/h3>
&lt;ol>
&lt;li>クライアントは取得した device_cert と device_key を用い、mTLS で CLN (node) に接続する。&lt;/li>
&lt;li>支払いやチャネル操作などの RPC 呼び出しを行う。&lt;/li>
&lt;li>署名が必要な場合、CLN は Signer (HSM) へ HsmRequest を送信し、秘密鍵を外部に渡さずに署名のみを実行する。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="signer-フロー-hsmrequest--hsmservice">Signer フロー (HSMRequest / HsmService)&lt;/h2>
&lt;p>CLN は秘密鍵が必要なとき、Node Service の StreamHsmRequests を用いて外部サイナー (Signer/HSM) へ HsmRequest を通知する。Signer はローカルで署名を実施し、HsmResponse で返す。具体的な流れは以下の通りである。&lt;/p></description></item></channel></rss>