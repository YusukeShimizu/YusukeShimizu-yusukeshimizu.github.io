<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on blog</title><link>https://yusukeshimizu.github.io/blog/posts/</link><description>Recent content in Posts on blog</description><generator>Hugo -- 0.145.0</generator><language>en</language><lastBuildDate>Thu, 27 Mar 2025 11:34:54 +0900</lastBuildDate><atom:link href="https://yusukeshimizu.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Wallet Recover</title><link>https://yusukeshimizu.github.io/blog/posts/wallet-recover/</link><pubDate>Thu, 27 Mar 2025 11:34:54 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/wallet-recover/</guid><description>&lt;p>mnemonic seedを保持していれば、ウォレットの残高をリカバリーできる。これは一見不思議だが、実際には無限に生成可能なアドレス（script pubkey）のうち、使用されたものだけを検出し、UTXOを取得する仕組みがあるためである。どのアドレスが使われたかを追跡できるからこそ、seedを頼りに残高を復元できる。&lt;/p>
&lt;p>しかし、mnemonic seedを持っているのに残高が正しく復旧しないケースも存在する。また、レガシーSegWit（P2SHアドレス・3xxxx）の潜在的な危険性は誤解を生みやすい。これらを整理するために、btc walletの実装（https://github.com/btcsuite/btcwallet）を例にしながら、BIP0044/49/84/86が規定するHDウォレット構造と、ウォレットのリカバリー方法を示す。&lt;/p>
&lt;h2 id="bipの概要と相互関係">BIPの概要と相互関係&lt;/h2>
&lt;p>BIP0044、BIP0049、BIP0084、BIP0086はいずれもHDウォレットの「目的（purpose）番号」を定義し、各アドレス形式を区別している。以下、それぞれの要点をまとめる。&lt;/p>
&lt;h3 id="bip44">BIP44&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>概要&lt;/strong>: &lt;code>m/44'/coin_type'/account'/change/address_index&lt;/code> の構造を規定する汎用的HDウォレット標準。&lt;/li>
&lt;li>&lt;strong>用途&lt;/strong>: レガシーP2PKH（1xxxx）アドレスに広く利用されてきた。複数通貨・複数アカウント管理が可能。&lt;/li>
&lt;li>&lt;strong>他BIPとの関係&lt;/strong>: 新しいアドレス形式に対応するBIP49やBIP84などは、このBIP44をベースにpurpose番号を変えて並立利用できる。&lt;/li>
&lt;/ul>
&lt;h3 id="bip49">BIP49&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>概要&lt;/strong>: &lt;code>m/49'/coin_type'/account'/change/address_index&lt;/code> を使い、P2WPKH-in-P2SH（3xxxx）アドレスを定義。&lt;/li>
&lt;li>&lt;strong>目的&lt;/strong>: 互換性を重視しつつ部分的にSegWitの恩恵（手数料削減など）を得るためのラップドSegWit。&lt;/li>
&lt;li>&lt;strong>他BIPとの関係&lt;/strong>: レガシー形式（BIP44）を補完し、新しいネイティブSegWit（BIP84）へ移行する中継的役割を果たす。&lt;/li>
&lt;/ul>
&lt;h3 id="bip84">BIP84&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>概要&lt;/strong>: &lt;code>m/84'/coin_type'/account'/change/address_index&lt;/code> の構造を使い、ネイティブSegWit（bech32、bc1q&amp;hellip;）アドレスを定義。&lt;/li>
&lt;li>&lt;strong>目的&lt;/strong>: SegWitの機能をフル活用し、より低い手数料やエラー検知の強化を実現。&lt;/li>
&lt;li>&lt;strong>他BIPとの関係&lt;/strong>: ラップドSegWit（BIP49）より進んだ純粋なSegWit。Taproot（BIP86）の前段階。&lt;/li>
&lt;/ul>
&lt;h3 id="bip86">BIP86&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>概要&lt;/strong>: &lt;code>m/86'/coin_type'/account'/change/address_index&lt;/code> を使い、Taproot（bech32m、bc1p&amp;hellip;）アドレス（単独所有向け）を定義。&lt;/li>
&lt;li>&lt;strong>目的&lt;/strong>: Schnorr署名やMASTなどTaprootの恩恵（手数料削減・プライバシー向上）を得る。現時点ではシングルキー中心だが、将来的な拡張も想定。&lt;/li>
&lt;li>&lt;strong>他BIPとの関係&lt;/strong>: ネイティブSegWit（BIP84）より先進的なP2TR形態を扱う。purpose番号86を使い、既存形式と衝突しない。&lt;/li>
&lt;/ul>
&lt;h2 id="bip49がlegacy-segwitと呼ばれる理由">BIP49が「legacy segwit」と呼ばれる理由&lt;/h2>
&lt;p>BIP49のP2WPKH-in-P2SHアドレス（3xxxx）は見た目が通常のP2SHと同じため、一般に「legacy segwit」とも呼ばれる。P2SHの場合、redeemScriptをユーザ側で保持する必要があるが、BIP49対応ウォレット（例: 多くのハードウェアウォレットなど）を使うなら、redeemScriptを個別にバックアップしなくても済む。&lt;/p>
&lt;h2 id="アドレスインデックスとリカバリー">アドレスインデックスとリカバリー&lt;/h2>
&lt;p>アドレスインデックス（&lt;code>address_index&lt;/code>）はウォレットが生成したアドレス数に応じて変化する。復旧時には何番目までアドレスを生成してスキャンするかを決める必要がある。btc walletでは以下のアルゴリズムにより、使用中のアドレスを取りこぼさずに効率的なブロックスキャンを行う。&lt;/p>
&lt;pre class="mermaid">sequenceDiagram
participant RM as RecoveryManager
participant RS as RecoveryState
participant BRS as BranchRecoveryState
participant BC as Blockchain
Note over RM: (Resurrectで&amp;lt;br&amp;gt;既存のアドレス・UTXOを復元)
loop until 全ブロックスキャン完了
RM-&amp;gt;BC: 次のブロック(群)取得
BC--&amp;gt;RM: BlockBatch返却
RM-&amp;gt;RS: State取得
RM-&amp;gt;&amp;gt;BRS: ExtendHorizon()呼び出し
alt horizonが不足
BRS-&amp;gt;&amp;gt;BRS: horizonを拡張&amp;lt;br&amp;gt;(nextUnfound + recoveryWindow)
note right of BRS: 無効インデックス数も考慮
end
RM-&amp;gt;BC: FilterBlocksRequest(生成済みアドレスを照合)
BC--&amp;gt;RM: FilterBlocksResponse(発見されたaddrのindex)
RM-&amp;gt;&amp;gt;BRS: ReportFound(index)
alt 新しい発見がありnextUnfoundが進む
BRS-&amp;gt;&amp;gt;BRS: horizon再チェック
end
end
Note over RM: 発見された中で最も高いインデックス +&amp;lt;br&amp;gt;recoveryWindow + 無効インデックス数まで生成し続ける
&lt;/pre>
&lt;ol>
&lt;li>&lt;strong>Resurrect&lt;/strong>&lt;br>
既知のアドレスやUTXOを &lt;code>RecoveryState&lt;/code> に登録し、初期状態をセットする。&lt;/li>
&lt;li>&lt;strong>ExtendHorizon&lt;/strong>&lt;br>
&lt;code>nextUnfound + recoveryWindow (+ 無効インデックス数)&lt;/code> までアドレスを導出・監視対象に加えておき、取りこぼしを防ぐ。&lt;/li>
&lt;li>&lt;strong>FilterBlocks&lt;/strong>&lt;br>
実際にブロックをスキャンし、高いインデックスのアドレスが見つかったら &lt;code>ReportFound&lt;/code> で更新し、さらに &lt;code>horizon&lt;/code> を見直す。&lt;/li>
&lt;li>&lt;strong>最終的に&lt;/strong>&lt;br>
最も高いインデックス + recoveryWindow + 無効インデックス数まで検査し、使われている可能性のあるアドレスを漏れなく拾う。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>mnemonic seedさえあれば複数のアドレス形式（P2PKH、P2WPKH-in-P2SH、P2WPKH、Taprootなど）をまとめて手堅くリカバリーできる。目的番号（purpose）を切り替えながら、ウォレットは無数に生成しうるアドレスのうち実使用されたものを判別して残高を復元する。&lt;/p></description></item><item><title>elip-0200</title><link>https://yusukeshimizu.github.io/blog/posts/elip-0200-ja/</link><pubDate>Mon, 24 Mar 2025 16:56:49 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/elip-0200-ja/</guid><description>&lt;p>ELIP 0200の日本語訳。Elements Improvement Proposals (ELIPs) は、BitcoinのBIPに相当するElementsプロジェクトの改善提案である。&lt;/p>
&lt;p>この記事はllmによる機械翻訳に基づく。誤りの可能性がある点に留意すること。&lt;br>
この内容はcommit hash&lt;br>
&lt;a href="https://github.com/ElementsProject/ELIPs/tree/9f08b8168328691c1bff6e0261cebbe985f39ae4">9f08b8168328691c1bff6e0261cebbe985f39ae4&lt;/a>&lt;br>
時点のリポジトリを参照している。&lt;/p>
&lt;hr>
&lt;p>ELIP: 200&lt;br>
Layer: Applications&lt;br>
Title: Confidential Transactions の割引料金&lt;br>
Author: Byron Hambly &lt;a href="mailto:bhambly@blockstream.com">bhambly@blockstream.com&lt;/a>&lt;br>
Comments-Summary: まだコメントはない&lt;br>
Comments-URI: &lt;a href="https://github.com/ElementsProject/elips/wiki/Comments:ELIP-0200">https://github.com/ElementsProject/elips/wiki/Comments:ELIP-0200&lt;/a>&lt;br>
Status: Draft&lt;br>
Type: Standards Track&lt;br>
Created: 2024-06-19&lt;br>
License: BSD-3-Clause&lt;/p>
&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;h3 id="概要">概要&lt;/h3>
&lt;p>Confidential Transactions (CT) の取引手数料を割引する方法を提案する。これにより、ウォレットが割引手数料率を算出可能になり、ノードが割引されたCTをリレー・採掘するための要件を定義する。&lt;/p>
&lt;h3 id="copyright">Copyright&lt;/h3>
&lt;p>本書は3条項BSDライセンスの下で公開している。&lt;/p>
&lt;h3 id="motivation">Motivation&lt;/h3>
&lt;p>ElementsにおけるCTは、明示的な取引よりサイズが約10倍大きい。&lt;br>
Pedersenコミットメントやアセットコミットメント、ECDHエフェメラルキーなどが追加され、さらにレンジプルーフとサージェクションプルーフを含むウィットネスデータが大きな要因である。&lt;br>
サイズが大きいほど手数料が高くなるため、ユーザがCTによるプライバシーを犠牲にし、明示的な取引を選びやすくなる可能性がある。&lt;br>
このELIPは、ElementsでCTを割引料金で受け入れるポリシー変更を提案し、CTと明示的な取引を同等の手数料規模に近づけ、明示的取引優先の動機を下げる。&lt;/p>
&lt;h2 id="design">Design&lt;/h2>
&lt;h3 id="overview">Overview&lt;/h3>
&lt;p>新たに「discount virtual size (discountvsize)」を導入する。&lt;br>
明示的な取引では通常のvsizeと実質同じ値となるが、CTでは秘密出力が含まれるたびに、各出力分の重みを仮想サイズ計算の前に減少させる。&lt;/p>
&lt;p>ウォレットは、この割引計算を用いて手数料を推定し、ノードはメンプールへの受け入れやピアへのメッセージングでdiscountvsizeを利用する。これによってCT取引の中継と採掘が行われる。&lt;/p>
&lt;h3 id="欠点">欠点&lt;/h3>
&lt;p>ディスカウントを導入すると、実際のコストは表面上の手数料率より低くなる。&lt;br>
既存のブロックアセンブラは先祖手数料率が高い取引から優先するため、割引CTは同じ「表面料金率」の明示的トランザクションなどより選択が遅れる。&lt;br>
この状態を解消するには、ブロックアセンブラ側で割引された仮想サイズを基準に手数料率を扱うよう変更が必要だが、最大料金追求よりCTのプライバシー優先を許容するというトレードオフとなる。&lt;/p>
&lt;h3 id="仕様">仕様&lt;/h3>
&lt;h4 id="ウォレット">ウォレット&lt;/h4>
&lt;p>ウォレットは通常の手順で取引を作成し、まずプレースホルダーの手数料出力を含める。&lt;br>
ダミー署名を埋め込んだ後、BIP-0141&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> に従い以下の式で重みを算出する:&lt;/p>
&lt;p>Weight = (Base transaction size * 3) + Total transaction size&lt;/p></description></item><item><title>[podcast]OP_CTV</title><link>https://yusukeshimizu.github.io/blog/posts/podcast-OP_CTV/</link><pubDate>Mon, 24 Mar 2025 16:07:31 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/podcast-OP_CTV/</guid><description>&lt;p>&lt;a href="https://d-central.tech/understanding-op_ctv-bip-119-in-bitcoin/">https://d-central.tech/understanding-op_ctv-bip-119-in-bitcoin/&lt;/a> をinputとし、podcastfyを用いて作成したもの。&lt;/p>
&lt;figure >
&lt;audio controls preload="metadata">
&lt;source src="https://yusukeshimizu.github.io/blog/OP_CTV.mp3" type="audio/mpeg">
&lt;/audio>
&lt;/figure>
&lt;hr>
&lt;h2 id="次世代ビットコインへの扉op_">&lt;strong>「次世代ビットコインへの扉：OP_CTVがもたらす革新とは？」&lt;/strong>&lt;/h2>
&lt;p>今回のポッドキャストでは、ビットコインの新提案「OP_CTV (BIP 119)」を切り口に、ビットコインがどんな未来を描こうとしているのかを探ります。秘密鍵を盗まれても即時に資金を抜かれない「ボルト（Vault）」機能や、複数人で１つのUTXOを共有できるShared UTXOによるスケーラビリティ改善など、セキュリティ・プライバシー・効率性を大幅にアップさせる可能性が語られました。&lt;/p>
&lt;p>一方で、政府の“ホワイトリスト”強制への懸念や、新機能導入による複雑化・セキュリティリスクも話題に。ビットコインが一貫して大切にしてきた「慎重で分散的な進化」は、OP_CTVにも当てはまります。ソフトフォークを経たコミュニティ合意が必要なことや、新機能の意義が正しく理解されるかが鍵。ビットコインの「堅牢さ」と「革新」がどう共存していくのか、目が離せない展開です。&lt;/p></description></item><item><title>CTV Template Hash詳細</title><link>https://yusukeshimizu.github.io/blog/posts/CTV-template-hash/</link><pubDate>Mon, 24 Mar 2025 13:21:13 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/CTV-template-hash/</guid><description>&lt;p>templateはなにが可変であり、なにが固定なのか、を整理する。&lt;br>
様々な場所に情報があるが、BIPに記されたpython codeを見るのが一番良い。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">ser_compact_size&lt;/span>(l):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> l &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">253&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Serialize as unsigned char&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">=&lt;/span> struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, l)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> l &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x10000&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">=&lt;/span> struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;&amp;lt;BH&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">253&lt;/span>, l)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> l &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x100000000&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Serialize as unsigned char 254 followed by unsigned 4 byte integer (little endian)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">=&lt;/span> struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;&amp;lt;BI&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">254&lt;/span>, l)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Serialize as unsigned char 255 followed by unsigned 8 byte integer (little endian)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">=&lt;/span> struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;&amp;lt;BQ&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">255&lt;/span>, l)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> r
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">ser_string&lt;/span>(s):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ser_compact_size(len(s)) &lt;span style="color:#f92672">+&lt;/span> s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CTxOut&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">serialize&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># serialize as signed 8 byte integer (little endian)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">+=&lt;/span> struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;&amp;lt;q&amp;#34;&lt;/span>, self&lt;span style="color:#f92672">.&lt;/span>nValue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">+=&lt;/span> ser_string(self&lt;span style="color:#f92672">.&lt;/span>scriptPubKey)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> r
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_default_check_template_precomputed_data&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># If there are no scriptSigs we do not need to precompute a hash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> any(inp&lt;span style="color:#f92672">.&lt;/span>scriptSig &lt;span style="color:#66d9ef">for&lt;/span> inp &lt;span style="color:#f92672">in&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>vin):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result[&lt;span style="color:#e6db74">&amp;#34;scriptSigs&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> sha256(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(ser_string(inp&lt;span style="color:#f92672">.&lt;/span>scriptSig) &lt;span style="color:#66d9ef">for&lt;/span> inp &lt;span style="color:#f92672">in&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>vin))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># The same value is also pre-computed for and defined in BIP-341 and can be shared.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># each nSequence is packed as 4 byte unsigned integer (little endian)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result[&lt;span style="color:#e6db74">&amp;#34;sequences&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> sha256(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;&amp;lt;I&amp;#34;&lt;/span>, inp&lt;span style="color:#f92672">.&lt;/span>nSequence) &lt;span style="color:#66d9ef">for&lt;/span> inp &lt;span style="color:#f92672">in&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>vin))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># The same value is also pre-computed for and defined in BIP-341 and can be shared&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># See class CTxOut above for details.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result[&lt;span style="color:#e6db74">&amp;#34;outputs&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> sha256(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(out&lt;span style="color:#f92672">.&lt;/span>serialize() &lt;span style="color:#66d9ef">for&lt;/span> out &lt;span style="color:#f92672">in&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>vout))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parameter precomputed must be passed &lt;span style="color:#f92672">in&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> DoS resistance
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_default_check_template_hash&lt;/span>(self, nIn, precomputed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> precomputed &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> precomputed &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>get_default_check_template_precomputed_data()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Serialize as 4 byte signed integer (little endian)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">+=&lt;/span> struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;&amp;lt;i&amp;#34;&lt;/span>, self&lt;span style="color:#f92672">.&lt;/span>nVersion)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Serialize as 4 byte unsigned integer (little endian)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">+=&lt;/span> struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;&amp;lt;I&amp;#34;&lt;/span>, self&lt;span style="color:#f92672">.&lt;/span>nLockTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># we do not include the hash in the case where there is no&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># scriptSigs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#e6db74">&amp;#34;scriptSigs&amp;#34;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> precomputed:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">+=&lt;/span> precomputed[&lt;span style="color:#e6db74">&amp;#34;scriptSigs&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Serialize as 4 byte unsigned integer (little endian)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">+=&lt;/span> struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;&amp;lt;I&amp;#34;&lt;/span>, len(self&lt;span style="color:#f92672">.&lt;/span>vin))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">+=&lt;/span> precomputed[&lt;span style="color:#e6db74">&amp;#34;sequences&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Serialize as 4 byte unsigned integer (little endian)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">+=&lt;/span> struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;&amp;lt;I&amp;#34;&lt;/span>, len(self&lt;span style="color:#f92672">.&lt;/span>vout))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">+=&lt;/span> precomputed[&lt;span style="color:#e6db74">&amp;#34;outputs&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Serialize as 4 byte unsigned integer (little endian)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">+=&lt;/span> struct&lt;span style="color:#f92672">.&lt;/span>pack(&lt;span style="color:#e6db74">&amp;#34;&amp;lt;I&amp;#34;&lt;/span>, nIn)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sha256(r)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>OP_CHECKTEMPLATEVERIFY（OP_CTV）は「将来使われるトランザクションの形をあらかじめ決めておき、そこから外れる支払いを無効とする」仕組みを提供する。したがって、意図しない送金や改ざんを防ぎながら、VaultやChannel Factoryのような特定用途の“Covenant”機能をシンプルかつ安全に実装できる。&lt;/p></description></item><item><title>bip-0119</title><link>https://yusukeshimizu.github.io/blog/posts/bip-0119-ja/</link><pubDate>Sat, 22 Mar 2025 08:56:49 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/bip-0119-ja/</guid><description>&lt;p>BIP 119の日本語訳をおいておく。&lt;/p>
&lt;p>この記事は、llmにより翻訳されたものであり、内容に誤りがある可能性はある。&lt;br>
BIP 119は、新しいオペコード OP_CHECKTEMPLATEVERIFY を有効化することを提案しており、このブログを書いた段階で、有力な選択肢となっている。&lt;br>
&lt;a href="https://www.coindesk.com/tech/2025/03/17/developer-consensus-may-be-converging-on-a-bitcoin-soft-fork-proposal-blockspace">Developer Consensus May Be Converging on a Bitcoin Soft Fork Proposal: Blockspace&lt;/a>&lt;/p>
&lt;p>なお、この記事は、commit hash&lt;a href="https://github.com/bitcoin/bips/blob/88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f/bip-0119.mediawiki">88c0fb9b5b7c3ed73386224c8c4ae0fd4fc3537f&lt;/a> 時点のものとなっている。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#abstract">Abstract&lt;/a>&lt;/li>
&lt;li>&lt;a href="#summary">Summary&lt;/a>&lt;/li>
&lt;li>&lt;a href="#motivation">Motivation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#detailed-specification">Detailed Specification&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4">デプロイ&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E8%80%83%E5%AE%9F%E8%A3%85">参考実装&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%A0%B9%E6%8B%A0">根拠&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#the-defaultchecktemplateverifyhash-of-the-transaction-at-the-current-input-index-matches-the-top-of-the-stack">The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#committing-to-the-version-and-locktime">Committing to the version and locktime&lt;/a>&lt;/li>
&lt;li>&lt;a href="#committing-to-the-scriptsigs-hash">Committing to the ScriptSigs Hash&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%82%A4%E3%83%B3%E3%83%97%E3%83%83%E3%83%88%E6%95%B0%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88">インプット数へのコミット&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%82%B7%E3%83%BC%E3%82%B1%E3%83%B3%E3%82%B9%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88">シーケンスハッシュへのコミット&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%82%A2%E3%82%A6%E3%83%88%E3%83%97%E3%83%83%E3%83%88%E6%95%B0%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88">アウトプット数へのコミット&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%82%A2%E3%82%A6%E3%83%88%E3%83%97%E3%83%83%E3%83%88%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88">アウトプットハッシュへのコミット&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%8F%BE%E5%9C%A8%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%97%E3%83%83%E3%83%88%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88">現在のインプットのインデックスへのコミット&lt;/a>&lt;/li>
&lt;li>&lt;a href="#committing-to-values-by-hash">Committing to Values by Hash&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-sha256">Using SHA256&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-non-tagged-hashes">Using Non-Tagged Hashes&lt;/a>&lt;/li>
&lt;li>&lt;a href="#the-ordering-of-fields">The Ordering of Fields&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E8%A8%AD%E8%A8%88%E4%B8%8A%E3%81%AE%E3%83%88%E3%83%AC%E3%83%BC%E3%83%89%E3%82%AA%E3%83%95%E3%81%A8%E3%83%AA%E3%82%B9%E3%82%AF">設計上のトレードオフとリスク&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#denial-of-service-and-validation-costs">Denial of Service and Validation Costs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%B0%B8%E4%B9%85%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E5%87%BA%E5%8A%9B">永久に使用できない出力&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E8%BB%A2%E9%80%81%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">転送アドレス&lt;/a>&lt;/li>
&lt;li>&lt;a href="#nop-default-and-recommended-standardness-rules">NOP-Default and Recommended Standardness Rules&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%A9%9F%E8%83%BD%E3%81%AE%E5%86%97%E9%95%B7%E6%80%A7">機能の冗長性&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%B0%86%E6%9D%A5%E7%9A%84%E3%81%AA%E3%82%A2%E3%83%83%E3%83%97%E3%82%B0%E3%83%AC%E3%83%BC%E3%83%89">将来的なアップグレード&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#checktemplateverify-%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3">CHECKTEMPLATEVERIFY バージョン&lt;/a>&lt;/li>
&lt;li>&lt;a href="#op_checksigfromstackverify">OP_CHECKSIGFROMSTACKVERIFY&lt;/a>&lt;/li>
&lt;li>&lt;a href="#op_amountverify">OP_AMOUNTVERIFY&lt;/a>&lt;/li>
&lt;li>&lt;a href="#op_catop_sha256stream">OP_CAT/OP_SHA256STREAM&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#backwards-compatibility">Backwards Compatibility&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E4%BA%92%E6%8F%9B%E6%80%A7">スクリプト互換性&lt;/a>&lt;/li>
&lt;li>&lt;a href="#references">References&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E9%A1%9E%E4%BC%BC%E3%81%97%E3%81%9F%E4%BB%A3%E6%9B%BF%E6%A1%88%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">類似した代替案について&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E8%91%97%E4%BD%9C%E6%A8%A9">著作権&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>BIP: 119&lt;br>
Layer: Consensus (soft fork)&lt;br>
Title: CHECKTEMPLATEVERIFY&lt;br>
Author: Jeremy Rubin &lt;a href="mailto:j@rubin.io">j@rubin.io&lt;/a>&lt;br>
Comments-URI: &lt;a href="https://github.com/bitcoin/bips/wiki/Comments:BIP-0119">https://github.com/bitcoin/bips/wiki/Comments:BIP-0119&lt;/a>&lt;br>
Status: Draft&lt;br>
Type: Standards Track&lt;br>
Created: 2020-01-06&lt;br>
License: BSD-3-Clause&lt;/p></description></item><item><title>[podcast]Covenants Everything</title><link>https://yusukeshimizu.github.io/blog/posts/Covenants_everything/</link><pubDate>Fri, 21 Mar 2025 16:07:31 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/Covenants_everything/</guid><description>&lt;p>&lt;a href="https://www.adoptblock.com/covenants-op-cat-op-ctv-english">https://www.adoptblock.com/covenants-op-cat-op-ctv-english&lt;/a> をinputとし、podcastfyを用いて作成したもの。
&lt;code>gpt-4o-mini-tts&lt;/code>を使うことで実用に耐える音声品質になった。&lt;/p>
&lt;figure >
&lt;audio controls preload="metadata">
&lt;source src="https://yusukeshimizu.github.io/blog/covenants.mp3" type="audio/mpeg">
&lt;/audio>
&lt;/figure>
&lt;hr>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>ビットコインのスケーラビリティ課題とKaspaとの比較&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>ビットコインのSidechainやLightningなどの拡張方法&lt;/li>
&lt;li>Kaspaは高速だが、フルノードでない点がセキュリティ上の妥協になる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ビットコインScriptとコヴナンツ入門&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>UTXOモデルとスタックベースの簡素な言語設計&lt;/li>
&lt;li>コヴナンツ（Covenants）で“UTXOの使い方”を厳しく制限・管理できるアイデア&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>主なコヴナンツの種類と特徴&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>トランザクションのハッシュ検証型、トランザクション内容検証型など&lt;/li>
&lt;li>再帰的に制限をかけることで、予期せぬ流動性の低下やファンジビリティ低下リスクがある&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>OPコード（オペコード）の拡張&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>過去に無効化されたOP_CAT再導入と、そのメリット・懸念&lt;/li>
&lt;li>OP_CHECKTEMPLATEVERIFY (OP_CTV) などのシンプルなコヴナンツ実装案&lt;/li>
&lt;li>それぞれのアプローチのトレードオフ（柔軟性と安全性のバランス）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ライトニングネットワークやEltooとの関係&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>ANYPREVOUT (BIP-118) でチャネル管理をシンプル化&lt;/li>
&lt;li>Vaultのアイデアなど、資金盗難への対抗策も議論される&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ビットコイン開発の進め方&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>SegWitやTaprootの導入にも長いテストと合意形成が必要だった&lt;/li>
&lt;li>大規模変更ほど、実装リスクとコミュニティの議論に時間を要する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>今後の展望と注意点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>コヴナンツ導入でDeFi的な活用も見据えられる&lt;/li>
&lt;li>ただし、BTCのファンジビリティや可用性を損なう恐れもあり、慎重な検証が必須&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Github Copilot Chat Commit Message Rules</title><link>https://yusukeshimizu.github.io/blog/posts/github-copilot-chat-commit-message-rules/</link><pubDate>Fri, 21 Mar 2025 09:28:58 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/github-copilot-chat-commit-message-rules/</guid><description>&lt;p>コミットメッセージを標準化するには、&lt;code>github.copilot.chat.commitMessageGeneration.instructions&lt;/code>を設定し、Copilot Chatが常に所定のルールに従うよう誘導するのが効果的である。たとえば、以下のように&lt;code>.vscode/settings.json&lt;/code>に記述する。&lt;/p>
&lt;p>他にも多様な方法があるが、ボタンをクリックするだけで設定できるため、結局これが使われていることが多いように思われる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsonc" data-lang="jsonc">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;github.copilot.chat.commitMessageGeneration.instructions&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;text&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;以下のルールに従ってコミットメッセージを生成:\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;1) 1行目は50文字以内\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;2) 本文が必要なら72文字幅で改行し、1行目と本文の間に空行\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;3) 現在形で書く (例: &amp;#39;Fix bug&amp;#39;, &amp;#39;Add feature&amp;#39;)\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;4) サブシステムやパッケージ名を先頭に (例: &amp;#39;wallet: &amp;#39;)\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;5) 箇条書きはハイフン(-)またはアスタリスク(*)で始める\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;6) 最後に &amp;#39;Generated by Copilot&amp;#39; と記載&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Copilot Chatは、この設定を参照してコミットメッセージを提案する。結果として、コミットメッセージの書式を一貫させ、読みやすい履歴管理を実現できる。commitlintなどと併用すれば、さらに厳格なバリデーションを行うことが可能である。&lt;/p></description></item><item><title>Wifi Off</title><link>https://yusukeshimizu.github.io/blog/posts/wifi-off/</link><pubDate>Fri, 21 Mar 2025 08:56:49 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/wifi-off/</guid><description>&lt;p>Wi-Fiを強制的にオフにすべきである。ネットからの通知やチャットへの意識を一掃し、思考を乱す要因を遮断できるからである。プログラミングや文章作成など、深い集中が必要な作業では特に有効である。&lt;/p>
&lt;p>Wi-Fiを切る前に必要資料をあらかじめ開いておくことが望ましい。ネット接続が必要な箇所は作業後にまとめて調べるべきである。スクリプトを用いれば、一定時間オフにしたまま強制的に待機できる。たとえばmacOSでは、以下のワンライナーが使える。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>networksetup -setairportpower en0 off &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sleep &lt;span style="color:#ae81ff">1800&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>networksetup -setairportpower en0 on &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>osascript -e &lt;span style="color:#e6db74">&amp;#39;display notification &amp;#34;WiFiが復活しました&amp;#34; with title &amp;#34;通知&amp;#34;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>資料を読み込み、作業に没頭し、後で必要部分のみ確認すればよい。緊急の連絡が想定される場合は注意が必要だが、そうでないならオフラインで集中すべきである。この手法によってフロー状態を維持しやすくなり、結果的に作業効率が上がると断言できる。&lt;/p>
&lt;p>または、私の実装したcliを使えば、より高度に設定することができる&lt;br>
&lt;a href="https://github.com/YusukeShimizu/rust-pomo">https://github.com/YusukeShimizu/rust-pomo&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>rust-pomo --focus &lt;span style="color:#ae81ff">1200&lt;/span> --break-time &lt;span style="color:#ae81ff">600&lt;/span> --cycles 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> Cycle 1/2: Focus time &lt;span style="color:#f92672">===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Setting WiFi off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Starting timer &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#ae81ff">1200&lt;/span> seconds...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#75715e">####################--------------------] 594s / 1200s &lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Greenlight における Scheduler と Signer/HSM のアーキテクチャ</title><link>https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/</link><pubDate>Wed, 19 Mar 2025 11:07:52 +0900</pubDate><guid>https://yusukeshimizu.github.io/blog/posts/greenlight_memo1/</guid><description>&lt;p>&lt;a href="https://github.com/Blockstream/greenlight/tree/adac70212c70119cc7e7174a742133e14dcdea0a/libs/proto/glclient">greenlight proto&lt;/a> をベースにした解説。&lt;/p>
&lt;p>greenlightはLightning Network（LN）の運用を簡易化するためのサービスである。しかし、どこが自己ホスト（self host）で、どこに信頼を置く必要があるのかが分かりにくい。SchedulerはLNノードの管理やスケジューリング機能を担うが、これは非公開のコードで動作し、ユーザーはその内部を直接検証できない。一方、Signerはトランザクション署名を行う重要なコンポーネントであり、cln（Core Lightning）はLightning Networkの実装である。これらは公開リポジトリとして誰でも参照できる。&lt;/p>
&lt;p>&lt;strong>目的と結論&lt;/strong>&lt;br>
Greenlight では、Scheduler (Closed Source) が Node 管理の中心にあり、UserClient (with integrated Signer/HSM) が Self-Hosted 環境で秘密鍵を保持する構造をとる。結論として、UserClient 側が鍵操作を制御しつつ、Greenlight 側の Scheduler が Node (CLN) を起動・管理する。これにより、秘密鍵をローカルで保持したまま Node をリモートで稼働させる運用が可能となる。&lt;/p>
&lt;hr>
&lt;h2 id="全体構造">全体構造&lt;/h2>
&lt;p>以下の図に示すように、UserClient (with integrated Signer/HSM) は自前の環境 (Self-Hosted) で動作する。一方、Scheduler は Greenlight が管理し、CLN (c-lightning+plugin) も Greenlight Hosted 環境で稼働する。UserClient は Scheduler に対して Manage API call を行い、Node に対する操作は Scheduler が CLN を経由して実行する。Signer/HSM は秘密鍵をローカルで保持し、署名要求のみを受け付ける。&lt;/p>
&lt;pre tabindex="0">&lt;code>(Self-Hosted) (Greenlight Hosted)
+-----------------------------------+ (Manage API call) +----------------------------+
| UserClient (with integrated | --------------------&amp;gt; | Scheduler (Closed Source) |
| Signer / HSM) | +-------------+--------------+
+-----------------------------------+ |
| (Node management)
| v
| +------------------------+
|-----------------------&amp;gt; |CLN (c-lightning+plugin)|
+-----------+------------+
&lt;/code>&lt;/pre>&lt;hr>
&lt;h2 id="ノード登録とスケジューリングフロー">ノード登録とスケジューリングフロー&lt;/h2>
&lt;h3 id="チャレンジ発行-getchallenge">チャレンジ発行 (GetChallenge)&lt;/h3>
&lt;ol>
&lt;li>スコープ (REGISTER や RECOVER) と node_id を指定し、Scheduler に GetChallenge をコールする。&lt;/li>
&lt;li>Scheduler は一度きり有効な challenge を生成し、ChallengeResponse に含めて返す。&lt;/li>
&lt;/ol>
&lt;h3 id="register--recover">Register / Recover&lt;/h3>
&lt;ol>
&lt;li>クライアントは challenge を秘密鍵で署名し、node_id、network、CSR などと共に送信する。&lt;/li>
&lt;li>Scheduler は署名検証後にノード所有権を確認し、mTLS のための device_cert と device_key を発行する。&lt;/li>
&lt;li>Register は新規発行、Recover は既存ノードの証明書再発行となる。&lt;/li>
&lt;/ol>
&lt;h3 id="schedule--getnodeinfo">Schedule / GetNodeInfo&lt;/h3>
&lt;ol>
&lt;li>クライアントは Schedule を呼び出し、ノード起動をリクエストする。&lt;/li>
&lt;li>Scheduler は CLN を割り当て、grpc_uri など接続情報を返す。&lt;/li>
&lt;li>すでに起動済みの場合、GetNodeInfo で接続情報を取得可能である。&lt;/li>
&lt;/ol>
&lt;h3 id="接続操作">接続・操作&lt;/h3>
&lt;ol>
&lt;li>クライアントは取得した device_cert と device_key を用い、mTLS で CLN (node) に接続する。&lt;/li>
&lt;li>支払いやチャネル操作などの RPC 呼び出しを行う。&lt;/li>
&lt;li>署名が必要な場合、CLN は Signer (HSM) へ HsmRequest を送信し、秘密鍵を外部に渡さずに署名のみを実行する。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="signer-フロー-hsmrequest--hsmservice">Signer フロー (HSMRequest / HsmService)&lt;/h2>
&lt;p>CLN は秘密鍵が必要なとき、Node Service の StreamHsmRequests を用いて外部サイナー (Signer/HSM) へ HsmRequest を通知する。Signer はローカルで署名を実施し、HsmResponse で返す。具体的な流れは以下の通りである。&lt;/p></description></item></channel></rss>